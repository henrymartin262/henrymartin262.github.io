<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="henry">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/02/10/ebpf_study/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Reference https:&#x2F;&#x2F;arttnba3.cn&#x2F;2023&#x2F;05&#x2F;31&#x2F;EBPF_0X00&#x2F;：适合入门了解ebpf  https:&#x2F;&#x2F;arthurchiao.art&#x2F;blog&#x2F;linux-socket-filtering-aka-bpf-zh&#x2F;：介绍的很全面（包括ebpf的一些内部机制）  https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;bpf&#x2F;index.">
<meta property="og:type" content="article">
<meta property="og:title" content="ebpf Basic Knowledge">
<meta property="og:url" content="http://example.com/2025/02/10/ebpf_study/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Reference https:&#x2F;&#x2F;arttnba3.cn&#x2F;2023&#x2F;05&#x2F;31&#x2F;EBPF_0X00&#x2F;：适合入门了解ebpf  https:&#x2F;&#x2F;arthurchiao.art&#x2F;blog&#x2F;linux-socket-filtering-aka-bpf-zh&#x2F;：介绍的很全面（包括ebpf的一些内部机制）  https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;bpf&#x2F;index.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-06.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-05.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-07.png">
<meta property="og:image" content="e:\ctf\fuzz\img\Snipaste_2024-07-28_21-43-23.png">
<meta property="og:image" content="e:\ctf\fuzz\img\Snipaste_2024-07-28_21-48-57.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-08.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-09.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-28_23-14-23.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-11.png">
<meta property="article:published_time" content="2025-02-10T13:26:52.662Z">
<meta property="article:modified_time" content="2025-02-10T13:31:21.054Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="ebpf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Snipaste_2024-05-07_01-07-06.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/icon.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/icon.png">
    <!--- Page Info-->
    
    <title>
        
            ebpf Basic Knowledge -
        
        Henry Martin
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left"},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-we3z86.webp","dark":"/images/wallhaven-6degr6.webp"},"title":"Welcome To Henry's Blog","subtitle":{"text":["a pwner from polaris"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/henrymartin262","instagram":"https://instagram.com","zhihu":"https://www.zhihu.com/","twitter":"https://twitter.com","email":"1551022913@qq.cmo"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":true,"type":"fixed","audios":[{"name":"Something Just Like This","artist":"Coldplay","url":"https://evan.beee.top/music/Something%20Just%20Like%20This%20-%20The%20Chainsmokers%E3%80%81Coldplay.mp3","cover":"https://evan.beee.top/music/covers/Something_Just_Like_This.png"}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.5.6","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Categories":{"path":"/categories/","icon":"fa-regular fa-folder"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"About":{"icon":"fa-regular fa-user","submenus":{"Links":"/links/","Github":"https://github.com/henrymartin262","Blog":"https://henrymartin262.github.io"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/11/24 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Henry Martin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-folder"></i>
                                        
                                        CATEGORIES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        TAGS
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        ABOUT&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/links/">LINKS
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/henrymartin262">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://henrymartin262.github.io">BLOG
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/categories/"  >
                             
                                
                                    <i class="fa-regular fa-folder"></i>
                                
                                CATEGORIES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/tags"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                TAGS
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                ABOUT&nbsp;<i class="group-hover:rotate-180 transition-transform fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="/links/">LINKS</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://github.com/henrymartin262">GITHUB</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://henrymartin262.github.io">BLOG</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                
                
                <img src="/images/Snipaste_2024-05-07_01-07-06.png" alt="ebpf Basic Knowledge" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75"/>
                
                <div class="w-full flex items-center absolute bottom-0 justify-start">
                    <h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-bold backdrop-blur-lg rounded-xl border border-border-color ">ebpf Basic Knowledge</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/henry.png">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">henry</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-02-10 21:26:52</span>
        <span class="mobile">2025-02-10 21:26:52</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-02-10 21:31:21</span>
            <span class="mobile">2025-02-10 21:31:21</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/Android/">Android</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/Android/kernel/">kernel</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/Android/kernel/ebpf/">ebpf</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/ebpf/">ebpf</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p><strong>Reference</strong></p>
<p><a class="link" target="_blank" rel="noopener" href="https://arttnba3.cn/2023/05/31/EBPF_0X00/%EF%BC%9A%E9%80%82%E5%90%88%E5%85%A5%E9%97%A8%E4%BA%86%E8%A7%A3ebpf">https://arttnba3.cn/2023/05/31/EBPF_0X00/：适合入门了解ebpf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" target="_blank" rel="noopener" href="https://arthurchiao.art/blog/linux-socket-filtering-aka-bpf-zh/%EF%BC%9A%E4%BB%8B%E7%BB%8D%E7%9A%84%E5%BE%88%E5%85%A8%E9%9D%A2%EF%BC%88%E5%8C%85%E6%8B%ACebpf%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%EF%BC%89">https://arthurchiao.art/blog/linux-socket-filtering-aka-bpf-zh/：介绍的很全面（包括ebpf的一些内部机制） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/bpf/index.html%EF%BC%9Abpf">https://www.kernel.org/doc/html/latest/bpf/index.html：bpf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 文档</p>
<p><a class="link" target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf/%EF%BC%9A%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%BA%9B">https://ebpf.io/what-is-ebpf/：里面有一些 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ebpf 相关的实验</p>
<blockquote>
<p>多半是抄的，仅供个人总结学习使用，侵删</p>
</blockquote>
<h1 id="eBPF学习笔记"><a href="#eBPF学习笔记" class="headerlink" title="eBPF学习笔记"></a>eBPF学习笔记</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>伯克利包过滤器</strong>（Berkeley Packet Filter）是一个 Linux kernel 中用以对来自于链路层的数据包进行过滤的架构，其位于内核中的架构如下图所示：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-05-07_01-07-06.png" alt="nipaste_2024-05-07_01-07-0"></p>
<p>BPF <strong>在内核中</strong>实现了一个新的<strong>虚拟机</strong>设计，通过<strong>即时编译</strong>（Just-In-Time compilation）技术将 BPF 指令翻译为 BPF 虚拟机的字节码，可以高效地工作在基于寄存器结构的 CPU 上</p>
<p>Linux kernel 自 3.18 版本起提供了<strong>扩展伯克利包过滤器</strong>（<strong>e</strong>xtended <strong>BPF</strong>，即 <code>eBPF</code>），其应用范围更广，能够被应用于更多的场景，原来的 BPF 被称为 <strong>c</strong>lassic <strong>BPF</strong>（cBPF），且目前基本上已经被废弃，Linux 会将 cBPF 字节码转化为 eBPF 字节码再执行</p>
<p>作为一个<strong>位于内核层面的虚拟机</strong>，eBPF 无疑为攻击者提供了相当大的新攻击面</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-05-07_01-07-05.png" alt="nipaste_2024-05-07_01-07-0"></p>
<p>用户程序首先会被生成 BPF 字节码，然后被加载到内核，这时候内核通过 <code>verifier</code>对字节码程序进行安全性检查，通过检查后便通过 JIT 编译运行，eBPF 程序主要分为如下类型：</p>
<ul>
<li><code>kprobes</code> ：内核中的动态跟踪，可以跟踪至内核中的函数入口或返回点</li>
<li><code>uprobes</code> ：用户空间中的动态跟踪，与 kprobes 不同的是跟踪的函数位于用户程序中</li>
<li><code>tracepoints</code> ：内核中的静态跟踪</li>
<li><code>perf_events</code> ：定时采样与 PMC</li>
</ul>
<p><strong>注意事项</strong>：上图中的 map 作为用以保存数据的通用结构，可以在不同的 eBPF 程序之间或是用户进程与内核间共享数据</p>
<p>同一个eBPF程序可以附加到多个事件, 并且不同的eBPF程序可以访问同一个映射, 示意图如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tracing     tracing    tracing    packet      packet     packet</span><br><span class="line">event A     event B    event C    on eth0     on eth1    on eth2</span><br><span class="line">|             |         |          |           |          ^</span><br><span class="line">|             |         |          |           v          |</span><br><span class="line">--&gt; tracing &lt;--     tracing      socket    tc ingress   tc egress</span><br><span class="line">     prog_1          prog_2      prog_3    classifier    action</span><br><span class="line">     |  |              |           |         prog_4      prog_5</span><br><span class="line">  |---  -----|  |------|          map_3        |           |</span><br><span class="line">map_1       map_2                              --| map_4 |--</span><br></pre></td></tr></table></figure></div>



<h3 id="verifier"><a href="#verifier" class="headerlink" title="verifier"></a>verifier</h3><p>在 eBPF 字节码被传入到内核空间后，其首先需要经过 <code>verifier</code> 的安全检查，之后才能进行 JIT 编译，verifier 主要检查以下几点：</p>
<ul>
<li>没有<strong>回向边</strong>（back edge）、<strong>环路</strong>（loop）、<strong>不可达</strong>（unreachable）指令</li>
<li><strong>不能在指针之间进行比较</strong>，指针只能与标量进行加减（eBPF 中的标量值为不从指针派生的值），verifier 会追踪哪些寄存器包含指针、哪些寄存器包含标量值</li>
<li><strong>指针运算不能离开一个 map 的“安全”边界</strong>，这意味着程序不能访问预定义的 map 外的内存，verifier 通过追踪每个寄存器值的上界与下界</li>
<li><strong>不能将指针存储在 map 中或作为返回值</strong>，以避免将内核地址泄露到用户空间</li>
</ul>
<p><strong>ALU Sanitation</strong></p>
<p><code>ALU Sanitation</code> 是 eBPF 中一个<strong>代码加固与运行时动态检测</strong>的框架，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足，这项技术通过调用 <code>fixup_bpf_calls()</code> <strong>为 eBPF 程序中的每一条指令的前面都添加上额外的辅助指令、替换部分指令</strong>等方式来实现</p>
<h3 id="ebpf-虚拟机"><a href="#ebpf-虚拟机" class="headerlink" title="ebpf 虚拟机"></a>ebpf 虚拟机</h3><p>eBPF 虚拟机本质上是 RISC 架构，一共有 11 个 64 位寄存器，一个程序计数器（PC）与一个固定大小的堆栈（通常为 512KB），在 x86 架构下的对应关系如下：</p>
<table>
<thead>
<tr>
<th>eBPF 寄存器</th>
<th>映射 x86_64 寄存器</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>R0</td>
<td>rax</td>
<td>函数返回值</td>
</tr>
<tr>
<td>R1</td>
<td>rdi</td>
<td>argv1</td>
</tr>
<tr>
<td>R2</td>
<td>rsi</td>
<td>argv2</td>
</tr>
<tr>
<td>R3</td>
<td>rdx</td>
<td>argv3</td>
</tr>
<tr>
<td>R4</td>
<td>rcx</td>
<td>argv4</td>
</tr>
<tr>
<td>R5</td>
<td>r8</td>
<td>argv5</td>
</tr>
<tr>
<td>R6</td>
<td>rbx</td>
<td>callee 保存</td>
</tr>
<tr>
<td>R7</td>
<td>r13</td>
<td>callee 保存</td>
</tr>
<tr>
<td>R8</td>
<td>r14</td>
<td>callee 保存</td>
</tr>
<tr>
<td>R9</td>
<td>r15</td>
<td>callee 保存</td>
</tr>
<tr>
<td>R10（只读）</td>
<td>rbp</td>
<td>堆栈指针寄存器</td>
</tr>
</tbody></table>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-05-07_01-07-07.png" alt="nipaste_2024-05-07_01-07-0"></p>
<p>在 eBPF 中，一个寄存器的状态信息使用 <code>bpf_reg_state</code> 进行表示</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> {</span></span><br><span class="line">	<span class="comment">/* Ordering of fields matters.  See states_equal() */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">	<span class="comment">/* Fixed part of pointer offset, pointer types only */</span></span><br><span class="line">	s32 off;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">		<span class="type">int</span> range;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">			<span class="comment">/* To distinguish map lookups from outer map</span></span><br><span class="line"><span class="comment">			 * the map_uid is non-zero for registers</span></span><br><span class="line"><span class="comment">			 * pointing to inner maps.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			u32 map_uid;</span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">			u32 btf_id;</span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		u32 mem_size; <span class="comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* For dynptr stack slots */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="class"><span class="keyword">enum</span> <span class="title">bpf_dynptr_type</span> <span class="title">type</span>;</span></span><br><span class="line">			<span class="comment">/* A dynptr is 16 bytes so it takes up 2 stack slots.</span></span><br><span class="line"><span class="comment">			 * We need to track which slot is the first slot</span></span><br><span class="line"><span class="comment">			 * to protect against cases where the user may try to</span></span><br><span class="line"><span class="comment">			 * pass in an address starting at the second slot of the</span></span><br><span class="line"><span class="comment">			 * dynptr.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">bool</span> first_slot;</span><br><span class="line">		} dynptr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> raw1;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> raw2;</span><br><span class="line">		} raw;</span><br><span class="line"></span><br><span class="line">		u32 subprogno; <span class="comment">/* for PTR_TO_FUNC */</span></span><br><span class="line">	};</span><br><span class="line">	<span class="comment">/* For PTR_TO_PACKET, used to find other pointers with the same variable</span></span><br><span class="line"><span class="comment">	 * offset, so they can share range knowledge.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we</span></span><br><span class="line"><span class="comment">	 * came from, when one is tested for != NULL.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MEM_OR_NULL this is used to identify memory allocation</span></span><br><span class="line"><span class="comment">	 * for the purpose of tracking that it's freed.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_SOCKET this is used to share which pointers retain the</span></span><br><span class="line"><span class="comment">	 * same reference to the socket, to determine proper reference freeing.</span></span><br><span class="line"><span class="comment">	 * For stack slots that are dynptrs, this is used to track references to</span></span><br><span class="line"><span class="comment">	 * the dynptr to determine proper reference freeing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="comment">/* PTR_TO_SOCKET and PTR_TO_TCP_SOCK could be a ptr returned</span></span><br><span class="line"><span class="comment">	 * from a pointer-cast helper, bpf_sk_fullsock() and</span></span><br><span class="line"><span class="comment">	 * bpf_tcp_sock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Consider the following where "sk" is a reference counted</span></span><br><span class="line"><span class="comment">	 * pointer returned from "sk = bpf_sk_lookup_tcp();":</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1: sk = bpf_sk_lookup_tcp();</span></span><br><span class="line"><span class="comment">	 * 2: if (!sk) { return 0; }</span></span><br><span class="line"><span class="comment">	 * 3: fullsock = bpf_sk_fullsock(sk);</span></span><br><span class="line"><span class="comment">	 * 4: if (!fullsock) { bpf_sk_release(sk); return 0; }</span></span><br><span class="line"><span class="comment">	 * 5: tp = bpf_tcp_sock(fullsock);</span></span><br><span class="line"><span class="comment">	 * 6: if (!tp) { bpf_sk_release(sk); return 0; }</span></span><br><span class="line"><span class="comment">	 * 7: bpf_sk_release(sk);</span></span><br><span class="line"><span class="comment">	 * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier will complain</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After bpf_sk_release(sk) at line 7, both "fullsock" ptr and</span></span><br><span class="line"><span class="comment">	 * "tp" ptr should be invalidated also.  In order to do that,</span></span><br><span class="line"><span class="comment">	 * the reg holding "fullsock" and "sk" need to remember</span></span><br><span class="line"><span class="comment">	 * the original refcounted ptr id (i.e. sk_reg-&gt;id) in ref_obj_id</span></span><br><span class="line"><span class="comment">	 * such that the verifier can reset all regs which have</span></span><br><span class="line"><span class="comment">	 * ref_obj_id matching the sk_reg-&gt;id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;ref_obj_id is set to sk_reg-&gt;id at line 1.</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;id will stay as NULL-marking purpose only.</span></span><br><span class="line"><span class="comment">	 * After NULL-marking is done, sk_reg-&gt;id can be reset to 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After "fullsock = bpf_sk_fullsock(sk);" at line 3,</span></span><br><span class="line"><span class="comment">	 * fullsock_reg-&gt;ref_obj_id is set to sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After "tp = bpf_tcp_sock(fullsock);" at line 5,</span></span><br><span class="line"><span class="comment">	 * tp_reg-&gt;ref_obj_id is set to fullsock_reg-&gt;ref_obj_id</span></span><br><span class="line"><span class="comment">	 * which is the same as sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * From the verifier perspective, if sk, fullsock and tp</span></span><br><span class="line"><span class="comment">	 * are not NULL, they are the same ptr with different</span></span><br><span class="line"><span class="comment">	 * reg-&gt;type.  In particular, bpf_sk_release(tp) is also</span></span><br><span class="line"><span class="comment">	 * allowed and has the same effect as bpf_sk_release(sk).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 ref_obj_id;</span><br><span class="line">	<span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">	 * the actual value.</span></span><br><span class="line"><span class="comment">	 * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">	 * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">	 * with the same id as us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">	<span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">	 * result in a bad access.</span></span><br><span class="line"><span class="comment">	 * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">	 * contents of the register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64 smin_value; <span class="comment">/* minimum possible (s64)value */</span></span><br><span class="line">	s64 smax_value; <span class="comment">/* maximum possible (s64)value */</span></span><br><span class="line">	u64 umin_value; <span class="comment">/* minimum possible (u64)value */</span></span><br><span class="line">	u64 umax_value; <span class="comment">/* maximum possible (u64)value */</span></span><br><span class="line">	s32 s32_min_value; <span class="comment">/* minimum possible (s32)value */</span></span><br><span class="line">	s32 s32_max_value; <span class="comment">/* maximum possible (s32)value */</span></span><br><span class="line">	u32 u32_min_value; <span class="comment">/* minimum possible (u32)value */</span></span><br><span class="line">	u32 u32_max_value; <span class="comment">/* maximum possible (u32)value */</span></span><br><span class="line">	<span class="comment">/* parentage chain for liveness checking */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="comment">/* Inside the callee two registers can be both PTR_TO_STACK like</span></span><br><span class="line"><span class="comment">	 * R1=fp-8 and R2=fp-8, but one of them points to this function stack</span></span><br><span class="line"><span class="comment">	 * while another to the caller's stack. To differentiate them 'frameno'</span></span><br><span class="line"><span class="comment">	 * is used which is an index in bpf_verifier_state-&gt;frame[] array</span></span><br><span class="line"><span class="comment">	 * pointing to bpf_func_state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 frameno;</span><br><span class="line">	<span class="comment">/* Tracks subreg definition. The stored value is the insn_idx of the</span></span><br><span class="line"><span class="comment">	 * writing insn. This is safe because subreg_def is used before any insn</span></span><br><span class="line"><span class="comment">	 * patching which only happens after main verification finished.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s32 subreg_def;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_liveness</span> <span class="title">live</span>;</span></span><br><span class="line">	<span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don't affect safety */</span></span><br><span class="line">	<span class="type">bool</span> precise;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p><strong>寄存器运行时值与边界范围校验</strong></p>
<p>eBPF 程序的安全主要是由 verifier 保证的，verifier 会<strong>模拟执行每一条指令</strong>并验证寄存器的值是否合法，主要关注这几个字段：</p>
<ul>
<li><code>smin_value</code>、<code>smax_value</code>： 64 位有符号的值的可能取值边界</li>
<li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li>
<li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li>
<li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li>
</ul>
<p>而寄存器中<strong>可以确定的值</strong>实际上通过 <code>var_off</code> 字段进行表示，该值用一个 <code>tnum</code> 结构体表示，<strong>mask 中为 0 对应的 value 位为已知位</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> {</span></span><br><span class="line">	u64 value;</span><br><span class="line">	u64 mask;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>一个 verifier 完全未知的寄存器如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">tnum_unknown</span> =</span> { .value = <span class="number">0</span>, .mask = <span class="number">-1</span> };</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：需要注意的是寄存器边界值是 verifier 通过模拟执行推测出来的，<strong>运行时的寄存器值不一定与 verifier 所推测的一致</strong>，这也曾是很多 eBPF 漏洞产生的原因</p>
<p><strong>寄存器类型</strong></p>
<p>寄存器在程序运行的不同阶段可能存放着不同类型的值，verifier 通过跟踪寄存器值的类型来防止越界访问的发生，主要有三类：</p>
<ul>
<li>未初始化（not init）：寄存器的初始状态，尚未经过任何赋值操作，此类寄存器不能参与运算</li>
<li>标量值（scalar）：该寄存器被赋予了整型值，此类寄存器不能被作为指针进行内存访问</li>
<li>指针类型（pointer）：该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* types of values stored in eBPF registers */</span></span><br><span class="line"><span class="comment">/* Pointer types represent:</span></span><br><span class="line"><span class="comment"> * pointer</span></span><br><span class="line"><span class="comment"> * pointer + imm</span></span><br><span class="line"><span class="comment"> * pointer + (u16) var</span></span><br><span class="line"><span class="comment"> * pointer + (u16) var + imm</span></span><br><span class="line"><span class="comment"> * if (range &gt; 0) then [ptr, ptr + range - off) is safe to access</span></span><br><span class="line"><span class="comment"> * if (id &gt; 0) means that some 'var' was added</span></span><br><span class="line"><span class="comment"> * if (off &gt; 0) means that 'imm' was added</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> {</span></span><br><span class="line">	NOT_INIT = <span class="number">0</span>,		 <span class="comment">/* nothing was written into register */</span></span><br><span class="line">	SCALAR_VALUE,		 <span class="comment">/* reg doesn't contain a valid pointer */</span></span><br><span class="line">	PTR_TO_CTX,		 <span class="comment">/* reg points to bpf_context */</span></span><br><span class="line">	CONST_PTR_TO_MAP,	 <span class="comment">/* reg points to struct bpf_map */</span></span><br><span class="line">	PTR_TO_MAP_VALUE,	 <span class="comment">/* reg points to map element value */</span></span><br><span class="line">	PTR_TO_MAP_KEY,		 <span class="comment">/* reg points to a map element key */</span></span><br><span class="line">	PTR_TO_STACK,		 <span class="comment">/* reg == frame_pointer + offset */</span></span><br><span class="line">	PTR_TO_PACKET_META,	 <span class="comment">/* skb-&gt;data - meta_len */</span></span><br><span class="line">	PTR_TO_PACKET,		 <span class="comment">/* reg points to skb-&gt;data */</span></span><br><span class="line">	PTR_TO_PACKET_END,	 <span class="comment">/* skb-&gt;data + headlen */</span></span><br><span class="line">	PTR_TO_FLOW_KEYS,	 <span class="comment">/* reg points to bpf_flow_keys */</span></span><br><span class="line">	PTR_TO_SOCKET,		 <span class="comment">/* reg points to struct bpf_sock */</span></span><br><span class="line">	PTR_TO_SOCK_COMMON,	 <span class="comment">/* reg points to sock_common */</span></span><br><span class="line">	PTR_TO_TCP_SOCK,	 <span class="comment">/* reg points to struct tcp_sock */</span></span><br><span class="line">	PTR_TO_TP_BUFFER,	 <span class="comment">/* reg points to a writable raw tp's buffer */</span></span><br><span class="line">	PTR_TO_XDP_SOCK,	 <span class="comment">/* reg points to struct xdp_sock */</span></span><br><span class="line">	<span class="comment">/* PTR_TO_BTF_ID points to a kernel struct that does not need</span></span><br><span class="line"><span class="comment">	 * to be null checked by the BPF program. This does not imply the</span></span><br><span class="line"><span class="comment">	 * pointer is _not_ null and in practice this can easily be a null</span></span><br><span class="line"><span class="comment">	 * pointer when reading pointer chains. The assumption is program</span></span><br><span class="line"><span class="comment">	 * context will handle null pointer dereference typically via fault</span></span><br><span class="line"><span class="comment">	 * handling. The verifier must keep this in mind and can make no</span></span><br><span class="line"><span class="comment">	 * assumptions about null or non-null when doing branch analysis.</span></span><br><span class="line"><span class="comment">	 * Further, when passed into helpers the helpers can not, without</span></span><br><span class="line"><span class="comment">	 * additional context, assume the value is non-null.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PTR_TO_BTF_ID,</span><br><span class="line">	<span class="comment">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span></span><br><span class="line"><span class="comment">	 * been checked for null. Used primarily to inform the verifier</span></span><br><span class="line"><span class="comment">	 * an explicit null check is required for this struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PTR_TO_MEM,		 <span class="comment">/* reg points to valid memory region */</span></span><br><span class="line">	PTR_TO_BUF,		 <span class="comment">/* reg points to a read/write buffer */</span></span><br><span class="line">	PTR_TO_FUNC,		 <span class="comment">/* reg points to a bpf program function */</span></span><br><span class="line">	CONST_PTR_TO_DYNPTR,	 <span class="comment">/* reg points to a const struct bpf_dynptr */</span></span><br><span class="line">	__BPF_REG_TYPE_MAX,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extended reg_types. */</span></span><br><span class="line">	PTR_TO_MAP_VALUE_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_MAP_VALUE,</span><br><span class="line">	PTR_TO_SOCKET_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_SOCKET,</span><br><span class="line">	PTR_TO_SOCK_COMMON_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_SOCK_COMMON,</span><br><span class="line">	PTR_TO_TCP_SOCK_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_TCP_SOCK,</span><br><span class="line">	PTR_TO_BTF_ID_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_BTF_ID,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This must be the last entry. Its purpose is to ensure the enum is</span></span><br><span class="line"><span class="comment">	 * wide enough to hold the higher bits reserved for bpf_type_flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__BPF_REG_TYPE_LIMIT	= BPF_TYPE_LIMIT,</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>



<h3 id="eBPF-指令与-eBPF-程序"><a href="#eBPF-指令与-eBPF-程序" class="headerlink" title="eBPF 指令与 eBPF 程序"></a>eBPF 指令与 eBPF 程序</h3><p>eBPF 为 RISC 指令集，单条 eBPF 指令在内核中定义为一个 <code>bpf_insn</code> 结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> {</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>相应地，一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写形如这样的结构体数组来描述一个 eBPF 程序，并作为 eBPF 程序字节码传入内核：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn) {                                \</span></span><br><span class="line"><span class="meta">        .code        = CODE,                            \</span></span><br><span class="line"><span class="meta">        .dst_reg     = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg     = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off         = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm         = IMM                              \</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">test_bpf_prog</span>[] =</span> {</span><br><span class="line">    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x114514</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>载入到内核中后，内核最终会使用一个 <code>bpf_prog</code> 结构体来表示一个 eBPF 程序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> {</span></span><br><span class="line">	u16			pages;		<span class="comment">/* Number of allocated pages */</span></span><br><span class="line">	u16			jited:<span class="number">1</span>,	<span class="comment">/* Is our filter JIT'ed? */</span></span><br><span class="line">				jit_requested:<span class="number">1</span>,<span class="comment">/* archs need to JIT the prog */</span></span><br><span class="line">				gpl_compatible:<span class="number">1</span>, <span class="comment">/* Is filter GPL compatible? */</span></span><br><span class="line">				cb_access:<span class="number">1</span>,	<span class="comment">/* Is control block accessed? */</span></span><br><span class="line">				dst_needed:<span class="number">1</span>,	<span class="comment">/* Do we need dst entry? */</span></span><br><span class="line">				blinding_requested:<span class="number">1</span>, <span class="comment">/* needs constant blinding */</span></span><br><span class="line">				blinded:<span class="number">1</span>,	<span class="comment">/* Was blinded */</span></span><br><span class="line">				is_func:<span class="number">1</span>,	<span class="comment">/* program is a bpf function */</span></span><br><span class="line">				kprobe_override:<span class="number">1</span>, <span class="comment">/* Do we override a kprobe? */</span></span><br><span class="line">				has_callchain_buf:<span class="number">1</span>, <span class="comment">/* callchain buffer allocated? */</span></span><br><span class="line">				enforce_expected_attach_type:<span class="number">1</span>, <span class="comment">/* Enforce expected_attach_type checking at attach time */</span></span><br><span class="line">				call_get_stack:<span class="number">1</span>, <span class="comment">/* Do we call bpf_get_stack() or bpf_get_stackid() */</span></span><br><span class="line">				call_get_func_ip:<span class="number">1</span>, <span class="comment">/* Do we call get_func_ip() */</span></span><br><span class="line">				tstamp_type_access:<span class="number">1</span>; <span class="comment">/* Accessed __sk_buff-&gt;tstamp_type */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span>	<span class="title">type</span>;</span>		<span class="comment">/* Type of BPF program */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_attach_type</span>	<span class="title">expected_attach_type</span>;</span> <span class="comment">/* For some prog types */</span></span><br><span class="line">	u32			len;		<span class="comment">/* Number of filter blocks */</span></span><br><span class="line">	u32			jited_len;	<span class="comment">/* Size of jited insns in bytes */</span></span><br><span class="line">	u8			tag[BPF_TAG_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span>;</span></span><br><span class="line">	<span class="type">int</span> __percpu		*active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>		<span class="params">(*bpf_func)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ctx,</span></span><br><span class="line"><span class="params">					    <span class="type">const</span> <span class="keyword">struct</span> bpf_insn *insn)</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_aux</span>	*<span class="title">aux</span>;</span>		<span class="comment">/* Auxiliary fields */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog_kern</span>	*<span class="title">orig_prog</span>;</span>	<span class="comment">/* Original BPF program */</span></span><br><span class="line">	<span class="comment">/* Instructions for interpreter */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		DECLARE_FLEX_ARRAY(<span class="keyword">struct</span> sock_filter, insns);</span><br><span class="line">		DECLARE_FLEX_ARRAY(<span class="keyword">struct</span> bpf_insn, insnsi);</span><br><span class="line">	};</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>



<h3 id="eBPF-map"><a href="#eBPF-map" class="headerlink" title="eBPF map"></a>eBPF map</h3><p>bpf map 是一个通用的用以储存不同种类数据的结构，用以在用户进程与 eBPF 程序、eBPF 程序与 eBPF 程序之间进行<strong>数据共享</strong>，这些数据以二进制形式储存，因此用户在创建时只需要指定 key 与 value 的 size</p>
<p>bpf map 主要有以下五个基本属性：</p>
<ul>
<li><code>type</code>：map 的数据结构类型</li>
<li><code>key_size</code>：以字节为单位的用以索引一个元素的 key 的 size（在数组映射中使用）</li>
<li><code>value_size</code>：以字节为单位的每个元素的 size</li>
<li><code>max_entries</code>：map 中 entries 的最大数量</li>
<li><code>map_flags</code>：描述 map 的独特特征，例如是否整个 map 的内存应被预先分配等</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> {</span></span><br><span class="line">	<span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment">	 * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">	u32 key_size;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	u32 max_entries;</span><br><span class="line">	u64 map_extra; <span class="comment">/* any per-map-type extra fields */</span></span><br><span class="line">	u32 map_flags;</span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf_record</span> *<span class="title">record</span>;</span></span><br><span class="line">	<span class="type">int</span> numa_node;</span><br><span class="line">	u32 btf_key_type_id;</span><br><span class="line">	u32 btf_value_type_id;</span><br><span class="line">	u32 btf_vmlinux_value_type_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf_field_offs</span> *<span class="title">field_offs</span>;</span></span><br><span class="line">	<span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment">	 * particularly with refcounting.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line">	<span class="type">atomic64_t</span> usercnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">	<span class="type">atomic64_t</span> writecnt;</span><br><span class="line">	<span class="comment">/* 'Ownership' of program-containing map is claimed by the first program</span></span><br><span class="line"><span class="comment">	 * that is going to use this map or by the first program which FD is</span></span><br><span class="line"><span class="comment">	 * stored in the map to make sure that all callers and callees have the</span></span><br><span class="line"><span class="comment">	 * same prog type, JITed flag and xdp_has_frags flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">		<span class="type">spinlock_t</span> lock;</span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span>;</span></span><br><span class="line">		<span class="type">bool</span> jited;</span><br><span class="line">		<span class="type">bool</span> xdp_has_frags;</span><br><span class="line">	} owner;</span><br><span class="line">	<span class="type">bool</span> bypass_spec_v1;</span><br><span class="line">	<span class="type">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p><strong>map 类型</strong></p>
<p>可选 map 类型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> {</span></span><br><span class="line">	BPF_MAP_TYPE_UNSPEC,</span><br><span class="line">	BPF_MAP_TYPE_HASH,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_PROG_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_PERF_EVENT_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_HASH,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_STACK_TRACE,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">	BPF_MAP_TYPE_LRU_PERCPU_HASH,</span><br><span class="line">	BPF_MAP_TYPE_LPM_TRIE,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY_OF_MAPS,</span><br><span class="line">	BPF_MAP_TYPE_HASH_OF_MAPS,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP,</span><br><span class="line">	BPF_MAP_TYPE_SOCKMAP,</span><br><span class="line">	BPF_MAP_TYPE_CPUMAP,</span><br><span class="line">	BPF_MAP_TYPE_XSKMAP,</span><br><span class="line">	BPF_MAP_TYPE_SOCKHASH,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,</span><br><span class="line">	<span class="comment">/* BPF_MAP_TYPE_CGROUP_STORAGE is available to bpf programs attaching</span></span><br><span class="line"><span class="comment">	 * to a cgroup. The newer BPF_MAP_TYPE_CGRP_STORAGE is available to</span></span><br><span class="line"><span class="comment">	 * both cgroup-attached and other progs and supports all functionality</span></span><br><span class="line"><span class="comment">	 * provided by BPF_MAP_TYPE_CGROUP_STORAGE. So mark</span></span><br><span class="line"><span class="comment">	 * BPF_MAP_TYPE_CGROUP_STORAGE deprecated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BPF_MAP_TYPE_CGROUP_STORAGE = BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,</span><br><span class="line">	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_QUEUE,</span><br><span class="line">	BPF_MAP_TYPE_STACK,</span><br><span class="line">	BPF_MAP_TYPE_SK_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP_HASH,</span><br><span class="line">	BPF_MAP_TYPE_STRUCT_OPS,</span><br><span class="line">	BPF_MAP_TYPE_RINGBUF,</span><br><span class="line">	BPF_MAP_TYPE_INODE_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_TASK_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_BLOOM_FILTER,</span><br><span class="line">	BPF_MAP_TYPE_USER_RINGBUF,</span><br><span class="line">	BPF_MAP_TYPE_CGRP_STORAGE,</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>常用的主要是以下几种类型：</p>
<ul>
<li><code>BPF_MAP_TYPE_HASH</code>：以哈希表形式存储键值对，比较常规</li>
<li><code>BPF_MAP_TYPE_ARRAY</code>：以数组形式存储键值对，<strong>key 即为数组下标，对应的 value 皆初始化为 0</strong></li>
<li><code>BPF_MAP_TYPE_PROG_ARRAY</code>：特殊的数组映射，<strong>value 为其他 eBPF 程序的文件描述符</strong></li>
<li><code>BPF_MAP_TYPE_STACK</code>：以栈形式存储数据</li>
</ul>
<h2 id="bpf-系统调用"><a href="#bpf-系统调用" class="headerlink" title="bpf 系统调用"></a>bpf 系统调用</h2><p>所有的操作其实都是通过 bpf 系统调用来完成的，其原型如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bpf(int cmd, union bpf_attr *attr, unsigned int size);</span><br></pre></td></tr></table></figure></div>

<h3 id="bpf-attr-结构体"><a href="#bpf-attr-结构体" class="headerlink" title="bpf_attr 结构体"></a>bpf_attr 结构体</h3><p>bpf 系统调用中的第二个参数是指向联合体 <code>bpf_attr</code> 的指针，定义于 <code>kernel/bpf/syscall.c</code> 中如下，对于不同的 <code>cmd</code> 而言其含义不同，因此这里是一个由多个结构体构成的联合体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">		__u32	map_type;	<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">		__u32	key_size;	<span class="comment">/* size of key in bytes */</span></span><br><span class="line">		__u32	value_size;	<span class="comment">/* size of value in bytes */</span></span><br><span class="line">		__u32	max_entries;	<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">		__u32	map_flags;	<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment">					 * flags defined above.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		__u32	inner_map_fd;	<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">		__u32	numa_node;	<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment">					 * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		<span class="type">char</span>	map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">		__u32	map_ifindex;	<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">		__u32	btf_fd;		<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">		__u32	btf_key_type_id;	<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">		__u32	btf_value_type_id;	<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">		__u32	btf_vmlinux_value_type_id;<span class="comment">/* BTF type_id of a kernel-</span></span><br><span class="line"><span class="comment">						   * struct stored as the</span></span><br><span class="line"><span class="comment">						   * map value</span></span><br><span class="line"><span class="comment">						   */</span></span><br><span class="line">		<span class="comment">/* Any per-map-type extra fields</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * BPF_MAP_TYPE_BLOOM_FILTER - the lowest 4 bits indicate the</span></span><br><span class="line"><span class="comment">		 * number of hash functions (if 0, the bloom filter will default</span></span><br><span class="line"><span class="comment">		 * to using 5 hash functions).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u64	map_extra;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_MAP_*_ELEM commands */</span></span><br><span class="line">		__u32		map_fd;</span><br><span class="line">		__aligned_u64	key;</span><br><span class="line">		<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">			__aligned_u64 value;</span><br><span class="line">			__aligned_u64 next_key;</span><br><span class="line">		};</span><br><span class="line">		__u64		flags;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* struct used by BPF_MAP_*_BATCH commands */</span></span><br><span class="line">		__aligned_u64	in_batch;	<span class="comment">/* start batch,</span></span><br><span class="line"><span class="comment">						 * NULL to start from beginning</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		__aligned_u64	out_batch;	<span class="comment">/* output: next start batch */</span></span><br><span class="line">		__aligned_u64	keys;</span><br><span class="line">		__aligned_u64	values;</span><br><span class="line">		__u32		count;		<span class="comment">/* input/output:</span></span><br><span class="line"><span class="comment">						 * input: # of key/value</span></span><br><span class="line"><span class="comment">						 * elements</span></span><br><span class="line"><span class="comment">						 * output: # of filled elements</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		__u32		map_fd;</span><br><span class="line">		__u64		elem_flags;</span><br><span class="line">		__u64		flags;</span><br><span class="line">	} batch;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_PROG_LOAD command */</span></span><br><span class="line">		__u32		prog_type;	<span class="comment">/* one of enum bpf_prog_type */</span></span><br><span class="line">		__u32		insn_cnt;</span><br><span class="line">		__aligned_u64	insns;</span><br><span class="line">		__aligned_u64	license;</span><br><span class="line">		__u32		log_level;	<span class="comment">/* verbosity level of verifier */</span></span><br><span class="line">		__u32		log_size;	<span class="comment">/* size of user buffer */</span></span><br><span class="line">		__aligned_u64	log_buf;	<span class="comment">/* user supplied buffer */</span></span><br><span class="line">		__u32		kern_version;	<span class="comment">/* not used */</span></span><br><span class="line">		__u32		prog_flags;</span><br><span class="line">		<span class="type">char</span>		prog_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">		__u32		prog_ifindex;	<span class="comment">/* ifindex of netdev to prep for */</span></span><br><span class="line">		<span class="comment">/* For some prog types expected attach type must be known at</span></span><br><span class="line"><span class="comment">		 * load time to verify attach type specific parts of prog</span></span><br><span class="line"><span class="comment">		 * (context accesses, allowed helpers, etc).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u32		expected_attach_type;</span><br><span class="line">		__u32		prog_btf_fd;	<span class="comment">/* fd pointing to BTF type data */</span></span><br><span class="line">		__u32		func_info_rec_size;	<span class="comment">/* userspace bpf_func_info size */</span></span><br><span class="line">		__aligned_u64	func_info;	<span class="comment">/* func info */</span></span><br><span class="line">		__u32		func_info_cnt;	<span class="comment">/* number of bpf_func_info records */</span></span><br><span class="line">		__u32		line_info_rec_size;	<span class="comment">/* userspace bpf_line_info size */</span></span><br><span class="line">		__aligned_u64	line_info;	<span class="comment">/* line info */</span></span><br><span class="line">		__u32		line_info_cnt;	<span class="comment">/* number of bpf_line_info records */</span></span><br><span class="line">		__u32		attach_btf_id;	<span class="comment">/* in-kernel BTF type id to attach to */</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">			<span class="comment">/* valid prog_fd to attach to bpf prog */</span></span><br><span class="line">			__u32		attach_prog_fd;</span><br><span class="line">			<span class="comment">/* or valid module BTF object fd or 0 to attach to vmlinux */</span></span><br><span class="line">			__u32		attach_btf_obj_fd;</span><br><span class="line">		};</span><br><span class="line">		__u32		core_relo_cnt;	<span class="comment">/* number of bpf_core_relo */</span></span><br><span class="line">		__aligned_u64	fd_array;	<span class="comment">/* array of FDs */</span></span><br><span class="line">		__aligned_u64	core_relos;</span><br><span class="line">		__u32		core_relo_rec_size; <span class="comment">/* sizeof(struct bpf_core_relo) */</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_OBJ_* commands */</span></span><br><span class="line">		__aligned_u64	pathname;</span><br><span class="line">		__u32		bpf_fd;</span><br><span class="line">		__u32		file_flags;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */</span></span><br><span class="line">		__u32		target_fd;	<span class="comment">/* container object to attach to */</span></span><br><span class="line">		__u32		attach_bpf_fd;	<span class="comment">/* eBPF program to attach */</span></span><br><span class="line">		__u32		attach_type;</span><br><span class="line">		__u32		attach_flags;</span><br><span class="line">		__u32		replace_bpf_fd;	<span class="comment">/* previously attached eBPF</span></span><br><span class="line"><span class="comment">						 * program to replace if</span></span><br><span class="line"><span class="comment">						 * BPF_F_REPLACE is used</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_PROG_TEST_RUN command */</span></span><br><span class="line">		__u32		prog_fd;</span><br><span class="line">		__u32		retval;</span><br><span class="line">		__u32		data_size_in;	<span class="comment">/* input: len of data_in */</span></span><br><span class="line">		__u32		data_size_out;	<span class="comment">/* input/output: len of data_out</span></span><br><span class="line"><span class="comment">						 *   returns ENOSPC if data_out</span></span><br><span class="line"><span class="comment">						 *   is too small.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		__aligned_u64	data_in;</span><br><span class="line">		__aligned_u64	data_out;</span><br><span class="line">		__u32		repeat;</span><br><span class="line">		__u32		duration;</span><br><span class="line">		__u32		ctx_size_in;	<span class="comment">/* input: len of ctx_in */</span></span><br><span class="line">		__u32		ctx_size_out;	<span class="comment">/* input/output: len of ctx_out</span></span><br><span class="line"><span class="comment">						 *   returns ENOSPC if ctx_out</span></span><br><span class="line"><span class="comment">						 *   is too small.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		__aligned_u64	ctx_in;</span><br><span class="line">		__aligned_u64	ctx_out;</span><br><span class="line">		__u32		flags;</span><br><span class="line">		__u32		cpu;</span><br><span class="line">		__u32		batch_size;</span><br><span class="line">	} test;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_*_GET_*_ID */</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">			__u32		start_id;</span><br><span class="line">			__u32		prog_id;</span><br><span class="line">			__u32		map_id;</span><br><span class="line">			__u32		btf_id;</span><br><span class="line">			__u32		link_id;</span><br><span class="line">		};</span><br><span class="line">		__u32		next_id;</span><br><span class="line">		__u32		open_flags;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_OBJ_GET_INFO_BY_FD */</span></span><br><span class="line">		__u32		bpf_fd;</span><br><span class="line">		__u32		info_len;</span><br><span class="line">		__aligned_u64	info;</span><br><span class="line">	} info;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_PROG_QUERY command */</span></span><br><span class="line">		__u32		target_fd;	<span class="comment">/* container object to query */</span></span><br><span class="line">		__u32		attach_type;</span><br><span class="line">		__u32		query_flags;</span><br><span class="line">		__u32		attach_flags;</span><br><span class="line">		__aligned_u64	prog_ids;</span><br><span class="line">		__u32		prog_cnt;</span><br><span class="line">		<span class="comment">/* output: per-program attach_flags.</span></span><br><span class="line"><span class="comment">		 * not allowed to be set during effective query.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__aligned_u64	prog_attach_flags;</span><br><span class="line">	} query;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct used by BPF_RAW_TRACEPOINT_OPEN command */</span></span><br><span class="line">		__u64 name;</span><br><span class="line">		__u32 prog_fd;</span><br><span class="line">	} raw_tracepoint;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* anonymous struct for BPF_BTF_LOAD */</span></span><br><span class="line">		__aligned_u64	btf;</span><br><span class="line">		__aligned_u64	btf_log_buf;</span><br><span class="line">		__u32		btf_size;</span><br><span class="line">		__u32		btf_log_size;</span><br><span class="line">		__u32		btf_log_level;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">		__u32		pid;		<span class="comment">/* input: pid */</span></span><br><span class="line">		__u32		fd;		<span class="comment">/* input: fd */</span></span><br><span class="line">		__u32		flags;		<span class="comment">/* input: flags */</span></span><br><span class="line">		__u32		buf_len;	<span class="comment">/* input/output: buf len */</span></span><br><span class="line">		__aligned_u64	buf;		<span class="comment">/* input/output:</span></span><br><span class="line"><span class="comment">						 *   tp_name for tracepoint</span></span><br><span class="line"><span class="comment">						 *   symbol for kprobe</span></span><br><span class="line"><span class="comment">						 *   filename for uprobe</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		__u32		prog_id;	<span class="comment">/* output: prod_id */</span></span><br><span class="line">		__u32		fd_type;	<span class="comment">/* output: BPF_FD_TYPE_* */</span></span><br><span class="line">		__u64		probe_offset;	<span class="comment">/* output: probe_offset */</span></span><br><span class="line">		__u64		probe_addr;	<span class="comment">/* output: probe_addr */</span></span><br><span class="line">	} task_fd_query;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* struct used by BPF_LINK_CREATE command */</span></span><br><span class="line">		__u32		prog_fd;	<span class="comment">/* eBPF program to attach */</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">			__u32		target_fd;	<span class="comment">/* object to attach to */</span></span><br><span class="line">			__u32		target_ifindex; <span class="comment">/* target ifindex */</span></span><br><span class="line">		};</span><br><span class="line">		__u32		attach_type;	<span class="comment">/* attach type */</span></span><br><span class="line">		__u32		flags;		<span class="comment">/* extra flags */</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">			__u32		target_btf_id;	<span class="comment">/* btf_id of target to attach to */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">				__aligned_u64	iter_info;	<span class="comment">/* extra bpf_iter_link_info */</span></span><br><span class="line">				__u32		iter_info_len;	<span class="comment">/* iter_info length */</span></span><br><span class="line">			};</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">				<span class="comment">/* black box user-provided value passed through</span></span><br><span class="line"><span class="comment">				 * to BPF program at the execution time and</span></span><br><span class="line"><span class="comment">				 * accessible through bpf_get_attach_cookie() BPF helper</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				__u64		bpf_cookie;</span><br><span class="line">			} perf_event;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">				__u32		flags;</span><br><span class="line">				__u32		cnt;</span><br><span class="line">				__aligned_u64	syms;</span><br><span class="line">				__aligned_u64	addrs;</span><br><span class="line">				__aligned_u64	cookies;</span><br><span class="line">			} kprobe_multi;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">				<span class="comment">/* this is overlaid with the target_btf_id above. */</span></span><br><span class="line">				__u32		target_btf_id;</span><br><span class="line">				<span class="comment">/* black box user-provided value passed through</span></span><br><span class="line"><span class="comment">				 * to BPF program at the execution time and</span></span><br><span class="line"><span class="comment">				 * accessible through bpf_get_attach_cookie() BPF helper</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				__u64		cookie;</span><br><span class="line">			} tracing;</span><br><span class="line">		};</span><br><span class="line">	} link_create;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* struct used by BPF_LINK_UPDATE command */</span></span><br><span class="line">		__u32		link_fd;	<span class="comment">/* link fd */</span></span><br><span class="line">		<span class="comment">/* new program fd to update link with */</span></span><br><span class="line">		__u32		new_prog_fd;</span><br><span class="line">		__u32		flags;		<span class="comment">/* extra flags */</span></span><br><span class="line">		<span class="comment">/* expected link's program fd; is specified only if</span></span><br><span class="line"><span class="comment">		 * BPF_F_REPLACE flag is set in flags */</span></span><br><span class="line">		__u32		old_prog_fd;</span><br><span class="line">	} link_update;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">		__u32		link_fd;</span><br><span class="line">	} link_detach;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* struct used by BPF_ENABLE_STATS command */</span></span><br><span class="line">		__u32		type;</span><br><span class="line">	} enable_stats;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* struct used by BPF_ITER_CREATE command */</span></span><br><span class="line">		__u32		link_fd;</span><br><span class="line">		__u32		flags;</span><br><span class="line">	} iter_create;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span> <span class="comment">/* struct used by BPF_PROG_BIND_MAP command */</span></span><br><span class="line">		__u32		prog_fd;</span><br><span class="line">		__u32		map_fd;</span><br><span class="line">		__u32		flags;		<span class="comment">/* extra flags */</span></span><br><span class="line">	} prog_bind_map;</span><br><span class="line"></span><br><span class="line">} __attribute__((aligned(<span class="number">8</span>)));</span><br></pre></td></tr></table></figure></div>



<h3 id="eBPF-指令格式"><a href="#eBPF-指令格式" class="headerlink" title="eBPF 指令格式"></a>eBPF 指令格式</h3><p>eBPF 单条指令长度固定为 8 字节，定义如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> {</span></span><br><span class="line">	__u8	code;		<span class="comment">/* 操作码 */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* 目的寄存器 */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* 源寄存器 */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* 有符号偏移 */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* 有符号立即数 */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>而 eBPF 实际上有两种编码模式：</p>
<ul>
<li>基础编码，单条指令为 64 bit</li>
<li>宽指令编码， <em>在基础编码后添加一个 64bit 的立即数</em> ，单条指令为 128 bit</li>
</ul>
<p>基础编码的指令格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>8 bits</th>
<th>4 bits</th>
<th>4 bits</th>
<th>16 bits</th>
<th>32 bits</th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>opcode(操作码)</td>
<td>dst_reg(目的寄存器)</td>
<td>src_reg(源寄存器)</td>
<td>off(有符号偏移)</td>
<td>imm(有符号32位立即数)</td>
</tr>
</tbody></table>
<p>eBPF 指令中的 <code>opcode</code> 域长度为 8 bit，其中<strong>低 3 位固定表示指令类型</strong>，剩下的高 5 位根据类型不同用途也不同</p>
<p>指令类型如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_LD</td>
<td>0x00</td>
<td>只能用于宽指令，从 <code>imm64</code> 中加载数据到寄存器</td>
</tr>
<tr>
<td>BPF_LDX</td>
<td>0x01</td>
<td>从内存中加载数据到 <code>dst_reg</code></td>
</tr>
<tr>
<td>BPF_ST</td>
<td>0x02</td>
<td>把 <code>imm32</code> 数据保存到内存中</td>
</tr>
<tr>
<td>BPF_STX</td>
<td>0x03</td>
<td>把 <code>src_reg</code> 寄存器数据保存到内存</td>
</tr>
<tr>
<td>BPF_ALU</td>
<td>0x04</td>
<td>32bit 算术运算</td>
</tr>
<tr>
<td>BPF_JMP</td>
<td>0x05</td>
<td>64bit 跳转操作</td>
</tr>
<tr>
<td>BPF_JMP32</td>
<td>0x06</td>
<td>32bit 跳转操作</td>
</tr>
<tr>
<td>BPF_ALU64</td>
<td>0x07</td>
<td>64bit 算术运算</td>
</tr>
</tbody></table>
<h3 id="算术-跳转指令"><a href="#算术-跳转指令" class="headerlink" title="算术 & 跳转指令"></a>算术 &amp; 跳转指令</h3><p>对于算术 &amp; 跳转指令而言由高位到低位分为三个部分：</p>
<table>
<thead>
<tr>
<th>4 bit</th>
<th>1 bit</th>
<th>3 bit</th>
</tr>
</thead>
<tbody><tr>
<td>operation code （操作代码）</td>
<td>source（源）</td>
<td>instruction class （指令类型）</td>
</tr>
</tbody></table>
<h4 id="①-操作代码"><a href="#①-操作代码" class="headerlink" title="① 操作代码"></a>① 操作代码</h4><p>opcode 的<strong>最高 4 bit 用来保存操作代码</strong>，对于算术指令而言有如下类型：</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>操作代码</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_ADD</td>
<td>0x00</td>
<td>dst += src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_SUB</td>
<td>0x10</td>
<td>dst -= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_MUL</td>
<td>0x20</td>
<td>dst *= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_DIV</td>
<td>0x30</td>
<td>dst /= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_OR</td>
<td>0x40</td>
<td>dst |= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_AND</td>
<td>0x50</td>
<td>dst &amp;= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_LSH</td>
<td>0x60</td>
<td>dst &lt;&lt;= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_RSH</td>
<td>0x70</td>
<td>dst &gt;&gt;= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_NEG</td>
<td>0x80</td>
<td>dst = ~src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_MOD</td>
<td>0x90</td>
<td>dst %= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_XOR</td>
<td>0xA0</td>
<td>dst ^= src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_MOV</td>
<td>0xB0</td>
<td>dst = src</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_ARSH</td>
<td>0xC0</td>
<td>算术右移操作（正数补 0 负数补 1 ）</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_END</td>
<td>0xD0</td>
<td>字节序转换</td>
</tr>
</tbody></table>
<p>对于跳转指令而言有如下类型：</p>
<table>
<thead>
<tr>
<th><strong>指令类型</strong></th>
<th><strong>操作代码</strong></th>
<th><strong>值</strong></th>
<th><strong>描述</strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_JMP</td>
<td>BPF_JA</td>
<td>0x00</td>
<td>PC += off</td>
<td>仅用于 BPF_JMP</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JEQ</td>
<td>0x10</td>
<td>PC += off if dst == src</td>
<td></td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JGT</td>
<td>0x20</td>
<td>PC += off if dst &gt; src</td>
<td></td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JGE</td>
<td>0x30</td>
<td>PC += off if dst &gt;= src</td>
<td></td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JSET</td>
<td>0x40</td>
<td>PC += off if dst &amp; src</td>
<td></td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JNE</td>
<td>0x50</td>
<td>PC += off if dst != src</td>
<td>仅 eBPF：不等时跳转</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JSGT</td>
<td>0x60</td>
<td>PC += off if dst &gt; src</td>
<td>仅 eBPF：有符号 ‘&gt;’</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JSGE</td>
<td>0x70</td>
<td>PC += off if dst &gt;= src</td>
<td>仅 eBPF：有符号 ‘&gt;=’</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_CALL</td>
<td>0x80</td>
<td>函数调用</td>
<td>仅 eBPF：函数调用</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_EXIT</td>
<td>0x90</td>
<td>函数或者程序返回</td>
<td>仅 eBPF：函数返回</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JLT</td>
<td>0xA0</td>
<td>PC += off if dst &lt; src</td>
<td>仅 eBPF：无符号 ‘&lt;’</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JLE</td>
<td>0xB0</td>
<td>PC += off if dst &lt;= src</td>
<td>仅 eBPF：无符号 ‘&lt;=’</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JSLT</td>
<td>0xC0</td>
<td>PC += off if dst &lt; src</td>
<td>仅 eBPF：有符号 ‘&lt;’</td>
</tr>
<tr>
<td>BPF_JMP / BPF_JMP64</td>
<td>BPF_JSLE</td>
<td>0xD0</td>
<td>PC += off if dst &lt;= src</td>
<td>仅 eBPF：有符号 ‘&lt;=’</td>
</tr>
</tbody></table>
<h4 id="②-源"><a href="#②-源" class="headerlink" title="② 源"></a>② 源</h4><p>opcode 中间的一个 bit 用来表示 <strong>源</strong> ，对于普通的跳转与算术指令而言含义如下表：</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>源</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_ALU / BPF_ALU64 / BPF_JMP / BPF_JMP64</td>
<td>BPF_K</td>
<td>0x00</td>
<td>使用32-bit <code>imm32</code> 作为源操作数</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64 / BPF_JMP / BPF_JMP64</td>
<td>BPF_X</td>
<td>0x08</td>
<td>使用源寄存器 （<code>src_reg</code>） 作为源操作数</td>
</tr>
</tbody></table>
<p>对于 <code>BPF_END</code> 操作码而言含义如下：</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>操作代码</th>
<th>源</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_END</td>
<td>BPF_TO_LE</td>
<td>0x00</td>
<td>转为小端序</td>
</tr>
<tr>
<td>BPF_ALU / BPF_ALU64</td>
<td>BPF_END</td>
<td>BPF_TO_BE</td>
<td>0x08</td>
<td>转为大端序</td>
</tr>
</tbody></table>
<h3 id="Load-Store-指令"><a href="#Load-Store-指令" class="headerlink" title="Load & Store 指令"></a>Load &amp; Store 指令</h3><p>对于 Load &amp; Store 指令而言，opcode 由高到低分为如下三部分：</p>
<table>
<thead>
<tr>
<th>3 bits</th>
<th>2 bit</th>
<th>3 bits</th>
</tr>
</thead>
<tbody><tr>
<td>mode（模式）</td>
<td>size（大小）</td>
<td>instruction class （指令类型）</td>
</tr>
</tbody></table>
<h4 id="①-大小"><a href="#①-大小" class="headerlink" title="① 大小"></a>① 大小</h4><p>Load &amp; Store 指令的 <strong>size</strong> 域用来表示<strong>操作的字节数</strong>：</p>
<blockquote>
<p>不知道为啥排序设为 4 2 1 8 :（</p>
</blockquote>
<table>
<thead>
<tr>
<th>大小</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_W</td>
<td>0x00</td>
<td>单字（4 字节）</td>
</tr>
<tr>
<td>BPF_H</td>
<td>0x08</td>
<td>半字（2字节）</td>
</tr>
<tr>
<td>BPF_B</td>
<td>0x10</td>
<td>单字节（1字节）</td>
</tr>
<tr>
<td>BPF_DW</td>
<td>0x18</td>
<td>双字（8字节）</td>
</tr>
</tbody></table>
<h4 id="②-模式"><a href="#②-模式" class="headerlink" title="② 模式"></a>② 模式</h4><p>Load &amp; Store 指令的 <strong>mode</strong> 域用来表示<strong>操作的模式</strong>，也就是如何去操作指定大小的数据：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>值</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_IMM</td>
<td>0x00</td>
<td>64 位立即数</td>
<td>eBPF 为64 位立即数，cBPF 中为 32 位</td>
</tr>
<tr>
<td>BPF_ABS</td>
<td>0x20</td>
<td>数据包直接访问</td>
<td>兼容自 cBPF 指令。R6 作为隐式输入，存放 <code>struct *sk_buff</code> ；R0 作为隐式输出，存放包中读出数据；R1 ~ R5 作为 scratch registers，在每次调用后会被清空</td>
</tr>
<tr>
<td>BPF_IND</td>
<td>0x40</td>
<td>数据包间接访问</td>
<td>同 BPF_ABS</td>
</tr>
<tr>
<td>BPF_MEM</td>
<td>0x60</td>
<td>赋值给 *(size *)(dst_reg + off)</td>
<td>标准 load &amp; store 操作</td>
</tr>
<tr>
<td>BPF_LEN</td>
<td>0x80</td>
<td>保留指令</td>
<td>仅用于 cBPF</td>
</tr>
<tr>
<td>BPF_MSH</td>
<td>0xA0</td>
<td>保留指令</td>
<td>仅用于 cBPF</td>
</tr>
<tr>
<td>BPF_XADD</td>
<td>0xC0</td>
<td>原子操作，*(无符号类型 *)(dst_reg + off16) 运算= src_reg</td>
<td>仅用于 eBPF，不支持 1 / 2 字节曹祖</td>
</tr>
</tbody></table>
<p>对于 <code>BPF_XADD</code>， <code>imm32</code> 域被用来表示原子操作的运算类型：</p>
<table>
<thead>
<tr>
<th>imm32</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_ADD</td>
<td>0x00</td>
<td>原子加</td>
</tr>
<tr>
<td>BPF_OR</td>
<td>0x40</td>
<td>原子或</td>
</tr>
<tr>
<td>BPF_AND</td>
<td>0x50</td>
<td>原子与</td>
</tr>
<tr>
<td>BPF_XOR</td>
<td>0xa0</td>
<td>原子异或</td>
</tr>
</tbody></table>
<p>这里尽可能列出所有组合后的命令。</p>
<h2 id="ALU-Instructions"><a href="#ALU-Instructions" class="headerlink" title="ALU Instructions"></a>ALU Instructions</h2><h3 id="64-bit"><a href="#64-bit" class="headerlink" title="64-bit"></a>64-bit</h3><table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Pseudocode</th>
</tr>
</thead>
<tbody><tr>
<td>0x07</td>
<td>add dst, imm</td>
<td>dst += imm</td>
</tr>
<tr>
<td>0x0f</td>
<td>add dst, src</td>
<td>dst += src</td>
</tr>
<tr>
<td>0x17</td>
<td>sub dst, imm</td>
<td>dst -= imm</td>
</tr>
<tr>
<td>0x1f</td>
<td>sub dst, src</td>
<td>dst -= src</td>
</tr>
<tr>
<td>0x27</td>
<td>mul dst, imm</td>
<td>dst *= imm</td>
</tr>
<tr>
<td>0x2f</td>
<td>mul dst, src</td>
<td>dst *= src</td>
</tr>
<tr>
<td>0x37</td>
<td>div dst, imm</td>
<td>dst /= imm</td>
</tr>
<tr>
<td>0x3f</td>
<td>div dst, src</td>
<td>dst /= src</td>
</tr>
<tr>
<td>0x47</td>
<td>or dst, imm</td>
<td>dst |= imm</td>
</tr>
<tr>
<td>0x4f</td>
<td>or dst, src</td>
<td>dst |= src</td>
</tr>
<tr>
<td>0x57</td>
<td>and dst, imm</td>
<td>dst &amp;= imm</td>
</tr>
<tr>
<td>0x5f</td>
<td>and dst, src</td>
<td>dst &amp;= src</td>
</tr>
<tr>
<td>0x67</td>
<td>lsh dst, imm</td>
<td>dst &lt;&lt;= imm</td>
</tr>
<tr>
<td>0x6f</td>
<td>lsh dst, src</td>
<td>dst &lt;&lt;= src</td>
</tr>
<tr>
<td>0x77</td>
<td>rsh dst, imm</td>
<td>dst &gt;&gt;= imm (logical)</td>
</tr>
<tr>
<td>0x7f</td>
<td>rsh dst, src</td>
<td>dst &gt;&gt;= src (logical)</td>
</tr>
<tr>
<td>0x87</td>
<td>neg dst</td>
<td>dst = -dst</td>
</tr>
<tr>
<td>0x97</td>
<td>mod dst, imm</td>
<td>dst %= imm</td>
</tr>
<tr>
<td>0x9f</td>
<td>mod dst, src</td>
<td>dst %= src</td>
</tr>
<tr>
<td>0xa7</td>
<td>xor dst, imm</td>
<td>dst ^= imm</td>
</tr>
<tr>
<td>0xaf</td>
<td>xor dst, src</td>
<td>dst ^= src</td>
</tr>
<tr>
<td>0xb7</td>
<td>mov dst, imm</td>
<td>dst = imm</td>
</tr>
<tr>
<td>0xbf</td>
<td>mov dst, src</td>
<td>dst = src</td>
</tr>
<tr>
<td>0xc7</td>
<td>arsh dst, imm</td>
<td>dst &gt;&gt;= imm (arithmetic)</td>
</tr>
<tr>
<td>0xcf</td>
<td>arsh dst, src</td>
<td>dst &gt;&gt;= src (arithmetic)</td>
</tr>
</tbody></table>
<h3 id="32-bit"><a href="#32-bit" class="headerlink" title="32-bit"></a>32-bit</h3><p>These instructions use only the lower 32 bits of their operands and zero the<br>upper 32 bits of the destination register.</p>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Pseudocode</th>
</tr>
</thead>
<tbody><tr>
<td>0x04</td>
<td>add32 dst, imm</td>
<td>dst += imm</td>
</tr>
<tr>
<td>0x0c</td>
<td>add32 dst, src</td>
<td>dst += src</td>
</tr>
<tr>
<td>0x14</td>
<td>sub32 dst, imm</td>
<td>dst -= imm</td>
</tr>
<tr>
<td>0x1c</td>
<td>sub32 dst, src</td>
<td>dst -= src</td>
</tr>
<tr>
<td>0x24</td>
<td>mul32 dst, imm</td>
<td>dst *= imm</td>
</tr>
<tr>
<td>0x2c</td>
<td>mul32 dst, src</td>
<td>dst *= src</td>
</tr>
<tr>
<td>0x34</td>
<td>div32 dst, imm</td>
<td>dst /= imm</td>
</tr>
<tr>
<td>0x3c</td>
<td>div32 dst, src</td>
<td>dst /= src</td>
</tr>
<tr>
<td>0x44</td>
<td>or32 dst, imm</td>
<td>dst |= imm</td>
</tr>
<tr>
<td>0x4c</td>
<td>or32 dst, src</td>
<td>dst |= src</td>
</tr>
<tr>
<td>0x54</td>
<td>and32 dst, imm</td>
<td>dst &amp;= imm</td>
</tr>
<tr>
<td>0x5c</td>
<td>and32 dst, src</td>
<td>dst &amp;= src</td>
</tr>
<tr>
<td>0x64</td>
<td>lsh32 dst, imm</td>
<td>dst &lt;&lt;= imm</td>
</tr>
<tr>
<td>0x6c</td>
<td>lsh32 dst, src</td>
<td>dst &lt;&lt;= src</td>
</tr>
<tr>
<td>0x74</td>
<td>rsh32 dst, imm</td>
<td>dst &gt;&gt;= imm (logical)</td>
</tr>
<tr>
<td>0x7c</td>
<td>rsh32 dst, src</td>
<td>dst &gt;&gt;= src (logical)</td>
</tr>
<tr>
<td>0x84</td>
<td>neg32 dst</td>
<td>dst = -dst</td>
</tr>
<tr>
<td>0x94</td>
<td>mod32 dst, imm</td>
<td>dst %= imm</td>
</tr>
<tr>
<td>0x9c</td>
<td>mod32 dst, src</td>
<td>dst %= src</td>
</tr>
<tr>
<td>0xa4</td>
<td>xor32 dst, imm</td>
<td>dst ^= imm</td>
</tr>
<tr>
<td>0xac</td>
<td>xor32 dst, src</td>
<td>dst ^= src</td>
</tr>
<tr>
<td>0xb4</td>
<td>mov32 dst, imm</td>
<td>dst = imm</td>
</tr>
<tr>
<td>0xbc</td>
<td>mov32 dst, src</td>
<td>dst = src</td>
</tr>
<tr>
<td>0xc4</td>
<td>arsh32 dst, imm</td>
<td>dst &gt;&gt;= imm (arithmetic)</td>
</tr>
<tr>
<td>0xcc</td>
<td>arsh32 dst, src</td>
<td>dst &gt;&gt;= src (arithmetic)</td>
</tr>
</tbody></table>
<h3 id="Byteswap-instructions"><a href="#Byteswap-instructions" class="headerlink" title="Byteswap instructions"></a>Byteswap instructions</h3><table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Pseudocode</th>
</tr>
</thead>
<tbody><tr>
<td>0xd4 (imm == 16)</td>
<td>le16 dst</td>
<td>dst = htole16(dst)</td>
</tr>
<tr>
<td>0xd4 (imm == 32)</td>
<td>le32 dst</td>
<td>dst = htole32(dst)</td>
</tr>
<tr>
<td>0xd4 (imm == 64)</td>
<td>le64 dst</td>
<td>dst = htole64(dst)</td>
</tr>
<tr>
<td>0xdc (imm == 16)</td>
<td>be16 dst</td>
<td>dst = htobe16(dst)</td>
</tr>
<tr>
<td>0xdc (imm == 32)</td>
<td>be32 dst</td>
<td>dst = htobe32(dst)</td>
</tr>
<tr>
<td>0xdc (imm == 64)</td>
<td>be64 dst</td>
<td>dst = htobe64(dst)</td>
</tr>
</tbody></table>
<h2 id="Memory-Instructions"><a href="#Memory-Instructions" class="headerlink" title="Memory Instructions"></a>Memory Instructions</h2><table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Pseudocode</th>
</tr>
</thead>
<tbody><tr>
<td>0x18</td>
<td>lddw dst, imm</td>
<td>dst = imm</td>
</tr>
<tr>
<td>0x20</td>
<td>ldabsw src, dst, imm</td>
<td>See kernel documentation</td>
</tr>
<tr>
<td>0x28</td>
<td>ldabsh src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x30</td>
<td>ldabsb src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x38</td>
<td>ldabsdw src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x40</td>
<td>ldindw src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x48</td>
<td>ldindh src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x50</td>
<td>ldindb src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x58</td>
<td>ldinddw src, dst, imm</td>
<td>…</td>
</tr>
<tr>
<td>0x61</td>
<td>ldxw dst, [src+off]</td>
<td>dst = *(uint32_t *) (src + off)</td>
</tr>
<tr>
<td>0x69</td>
<td>ldxh dst, [src+off]</td>
<td>dst = *(uint16_t *) (src + off)</td>
</tr>
<tr>
<td>0x71</td>
<td>ldxb dst, [src+off]</td>
<td>dst = *(uint8_t *) (src + off)</td>
</tr>
<tr>
<td>0x79</td>
<td>ldxdw dst, [src+off]</td>
<td>dst = *(uint64_t *) (src + off)</td>
</tr>
<tr>
<td>0x62</td>
<td>stw [dst+off], imm</td>
<td>*(uint32_t *) (dst + off) = imm</td>
</tr>
<tr>
<td>0x6a</td>
<td>sth [dst+off], imm</td>
<td>*(uint16_t *) (dst + off) = imm</td>
</tr>
<tr>
<td>0x72</td>
<td>stb [dst+off], imm</td>
<td>*(uint8_t *) (dst + off) = imm</td>
</tr>
<tr>
<td>0x7a</td>
<td>stdw [dst+off], imm</td>
<td>*(uint64_t *) (dst + off) = imm</td>
</tr>
<tr>
<td>0x63</td>
<td>stxw [dst+off], src</td>
<td>*(uint32_t *) (dst + off) = src</td>
</tr>
<tr>
<td>0x6b</td>
<td>stxh [dst+off], src</td>
<td>*(uint16_t *) (dst + off) = src</td>
</tr>
<tr>
<td>0x73</td>
<td>stxb [dst+off], src</td>
<td>*(uint8_t *) (dst + off) = src</td>
</tr>
<tr>
<td>0x7b</td>
<td>stxdw [dst+off], src</td>
<td>*(uint64_t *) (dst + off) = src</td>
</tr>
</tbody></table>
<h2 id="Branch-Instructions"><a href="#Branch-Instructions" class="headerlink" title="Branch Instructions"></a>Branch Instructions</h2><table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Pseudocode</th>
</tr>
</thead>
<tbody><tr>
<td>0x05</td>
<td>ja +off</td>
<td>PC += off</td>
</tr>
<tr>
<td>0x15</td>
<td>jeq dst, imm, +off</td>
<td>PC += off if dst == imm</td>
</tr>
<tr>
<td>0x1d</td>
<td>jeq dst, src, +off</td>
<td>PC += off if dst == src</td>
</tr>
<tr>
<td>0x25</td>
<td>jgt dst, imm, +off</td>
<td>PC += off if dst &gt; imm</td>
</tr>
<tr>
<td>0x2d</td>
<td>jgt dst, src, +off</td>
<td>PC += off if dst &gt; src</td>
</tr>
<tr>
<td>0x35</td>
<td>jge dst, imm, +off</td>
<td>PC += off if dst &gt;= imm</td>
</tr>
<tr>
<td>0x3d</td>
<td>jge dst, src, +off</td>
<td>PC += off if dst &gt;= src</td>
</tr>
<tr>
<td>0xa5</td>
<td>jlt dst, imm, +off</td>
<td>PC += off if dst &lt; imm</td>
</tr>
<tr>
<td>0xad</td>
<td>jlt dst, src, +off</td>
<td>PC += off if dst &lt; src</td>
</tr>
<tr>
<td>0xb5</td>
<td>jle dst, imm, +off</td>
<td>PC += off if dst &lt;= imm</td>
</tr>
<tr>
<td>0xbd</td>
<td>jle dst, src, +off</td>
<td>PC += off if dst &lt;= src</td>
</tr>
<tr>
<td>0x45</td>
<td>jset dst, imm, +off</td>
<td>PC += off if dst &amp; imm</td>
</tr>
<tr>
<td>0x4d</td>
<td>jset dst, src, +off</td>
<td>PC += off if dst &amp; src</td>
</tr>
<tr>
<td>0x55</td>
<td>jne dst, imm, +off</td>
<td>PC += off if dst != imm</td>
</tr>
<tr>
<td>0x5d</td>
<td>jne dst, src, +off</td>
<td>PC += off if dst != src</td>
</tr>
<tr>
<td>0x65</td>
<td>jsgt dst, imm, +off</td>
<td>PC += off if dst &gt; imm (signed)</td>
</tr>
<tr>
<td>0x6d</td>
<td>jsgt dst, src, +off</td>
<td>PC += off if dst &gt; src (signed)</td>
</tr>
<tr>
<td>0x75</td>
<td>jsge dst, imm, +off</td>
<td>PC += off if dst &gt;= imm (signed)</td>
</tr>
<tr>
<td>0x7d</td>
<td>jsge dst, src, +off</td>
<td>PC += off if dst &gt;= src (signed)</td>
</tr>
<tr>
<td>0xc5</td>
<td>jslt dst, imm, +off</td>
<td>PC += off if dst &lt; imm (signed)</td>
</tr>
<tr>
<td>0xcd</td>
<td>jslt dst, src, +off</td>
<td>PC += off if dst &lt; src (signed)</td>
</tr>
<tr>
<td>0xd5</td>
<td>jsle dst, imm, +off</td>
<td>PC += off if dst &lt;= imm (signed)</td>
</tr>
<tr>
<td>0xdd</td>
<td>jsle dst, src, +off</td>
<td>PC += off if dst &lt;= src (signed)</td>
</tr>
<tr>
<td>0x85</td>
<td>call imm</td>
<td>Function call</td>
</tr>
<tr>
<td>0x95</td>
<td>exit</td>
<td>return r0</td>
</tr>
</tbody></table>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[31m\033[1m[x] Error at: \033[0m%s\n"</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn) {                                \</span></span><br><span class="line"><span class="meta">        .code        = CODE,                            \</span></span><br><span class="line"><span class="meta">        .dst_reg     = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg     = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off         = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm         = IMM                              \</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">test_bpf_prog</span>[] =</span> {</span><br><span class="line">    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1131796</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_BPF_LOG_SZ 0x10000</span></span><br><span class="line"><span class="type">char</span> test_bpf_log_buf[TEST_BPF_LOG_SZ] = { <span class="string">'\0'</span> };</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">test_bpf_attr</span> =</span> {</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>) &amp;test_bpf_prog,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(test_bpf_prog) / <span class="keyword">sizeof</span>(test_bpf_prog[<span class="number">0</span>]),</span><br><span class="line">    .license = (<span class="type">uint64_t</span>) <span class="string">"GPL"</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>) test_bpf_log_buf,</span><br><span class="line">    .log_size = TEST_BPF_LOG_SZ,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> test_bpf_prog_fd;</span><br><span class="line">    <span class="type">char</span> *err_msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load bpf prog into kernel */</span></span><br><span class="line">    test_bpf_prog_fd = bpf(BPF_PROG_LOAD, &amp;test_bpf_attr);</span><br><span class="line">    <span class="keyword">if</span> (test_bpf_prog_fd &lt; <span class="number">0</span>) {</span><br><span class="line">        err_msg = <span class="string">"FAILED to load bpf program!"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bpf_load;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* output the log */</span></span><br><span class="line">    <span class="built_in">puts</span>(test_bpf_log_buf);</span><br><span class="line"></span><br><span class="line">    close(test_bpf_prog_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bpf_load:</span><br><span class="line">    <span class="built_in">puts</span>(test_bpf_log_buf);</span><br><span class="line">err_socket:</span><br><span class="line">    err_exit(err_msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//gcc -g test.c -o test_bpf_prog</span></span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="E:\ctf\fuzz\img\Snipaste_2024-07-28_21-43-23.png" alt="nipaste_2024-07-28_21-43-2"></p>
<h2 id="raw-eBPF-map-使用"><a href="#raw-eBPF-map-使用" class="headerlink" title="raw eBPF map 使用"></a>raw eBPF map 使用</h2><p>eBPF map 为以 <code>key→value</code> 映射格式存储数据的通用的数据存储结构，用于在不同程序之间共享数据，本节主要介绍 eBPF map 的基本用法</p>
<h3 id="创建-eBPF-map"><a href="#创建-eBPF-map" class="headerlink" title="创建 eBPF map"></a>创建 eBPF map</h3><p>可以通过 <code>BPF_MAP_CREATE</code> 命令创建一个新的 eBPF map，其会返回一个文件描述符作为该 map 的引用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> map_type, <span class="type">unsigned</span> <span class="type">int</span> key_size, </span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">int</span> value_size, <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_type = map_type,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="更新-eBPF-map"><a href="#更新-eBPF-map" class="headerlink" title="更新 eBPF map"></a>更新 eBPF map</h3><p>可以通过 <code>BPF_MAP_UPDATE</code> 命令更新 map 中对应的 <code>key→value</code> 映射：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_update_elem</span><span class="params">(<span class="type">int</span> map_fd,<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *value,<span class="type">uint64_t</span> flags)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) value,</span><br><span class="line">        .flags = flags,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>flags 应当为如下之一：</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>BPF_ANY</td>
<td>有则更新，无则新建</td>
<td></td>
</tr>
<tr>
<td>BPF_NOEXIST</td>
<td>仅在不存在时进行创建</td>
<td>若已有对应的 key 则返回 <code>-EEXIST</code></td>
</tr>
<tr>
<td>BPF_EXIST</td>
<td>仅在存在时进行更新</td>
<td>若无对应的 key 则返回 <code>-ENOENT</code></td>
</tr>
</tbody></table>
<p>在创建新映射时若 map 中映射数量已经达到 <code>max_entries</code> 则会返回 <code>E2BIG</code></p>
<h3 id="在-eBPF-map-中查找"><a href="#在-eBPF-map-中查找" class="headerlink" title="在 eBPF map 中查找"></a>在 eBPF map 中查找</h3><p>我们可以通过 <code>BPF_MAP_LOOKUP_ELEM</code> 命令查找 map 中是否存在对应的 key，若是则内核会将 value 拷贝到用户空间指定的 value 缓冲区</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_lookup_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> *value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) value,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="遍历-eBPF-map"><a href="#遍历-eBPF-map" class="headerlink" title="遍历 eBPF map"></a>遍历 eBPF map</h3><p><code>BPF_MAP_GET_NEXT_KEY</code> 是一个非常有意思的命令，其会在 map 中查找我们所传入的 key，并将该 key 的下一个 key 拷贝回用户空间，若不存在该 key 则会返回 0 并拷贝 map 中第一个 key 到用户空间，若该 key 为最后一个 key 则返回 <code>-1</code> ：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_get_next_key</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> *value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">        .next_key = (<span class="type">uint64_t</span>) value,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>利用这个命令我们可以很方便地遍历一个 eBPF map：先传入一个不存在的 key 获取到 map 中的第一个 key，接下来再不断 <code>BPF_MAP_GET_NEXT_KEY</code> 直到返回 <code>-1</code> 即可</p>
<h3 id="删除-eBPF-map-数据"><a href="#删除-eBPF-map-数据" class="headerlink" title="删除 eBPF map 数据"></a>删除 eBPF map 数据</h3><p>可以通过 <code>BPF_MAP_DELETE_ELEM</code> 命令删除 map 中已有的映射，若不存在则会返回 <code>-EPERM</code> ：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_delete_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="销毁-eBPF-map"><a href="#销毁-eBPF-map" class="headerlink" title="销毁 eBPF map"></a>销毁 eBPF map</h3><p>在内核的 eBPF map 数据结构中会保存引用了该 map 的程序数量，若该 map 不再被任一程序引用则会自动释放，因此并不需要主动去销毁一个 eBPF map</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> map_type, <span class="type">unsigned</span> <span class="type">int</span> key_size, </span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">int</span> value_size, <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_type = map_type,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_lookup_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> *value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) value,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_update_elem</span><span class="params">(<span class="type">int</span> map_fd,<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *value,<span class="type">uint64_t</span> flags)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) value,</span><br><span class="line">        .flags = flags,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">bpf_map_delete_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> {</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) key,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[31m\033[1m[x] Error at: \033[0m%s\n"</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> orig_value[<span class="number">0x100</span>] = <span class="string">"111222333444555"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> value[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> map_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*] Creating new eBPF map..."</span>);</span><br><span class="line">    map_fd = bpf_map_create(BPF_MAP_TYPE_HASH, <span class="number">0x10</span>, <span class="number">0x100</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) {</span><br><span class="line">        err_exit(<span class="string">"FAILED to create eBPF map!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*] Adding new map of key-&gt;value..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, <span class="string">"bsd_henry"</span>, orig_value, BPF_ANY) &lt; <span class="number">0</span>) {</span><br><span class="line">        err_exit(<span class="string">"FAILED to update eBPF map!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*] Looking up element in map..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_lookup_elem(map_fd, <span class="string">"bsd_henry"</span>, value) &lt; <span class="number">0</span>) {</span><br><span class="line">        err_exit(<span class="string">"FAILED to look up elem in eBPF map!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] Successfully get the elem of key %s: %s\n"</span>, <span class="string">"bsd_henry"</span>, value);</span><br><span class="line"></span><br><span class="line">    close(map_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="E:\ctf\fuzz\img\Snipaste_2024-07-28_21-48-57.png" alt="nipaste_2024-07-28_21-48-5"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>在很多情况下，eBPF 并不直接使用，而是通过<a class="link" target="_blank" rel="noopener" href="https://ebpf.io/projects/#cilium">Cilium <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link" target="_blank" rel="noopener" href="https://ebpf.io/projects/#bcc">bcc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>或<a class="link" target="_blank" rel="noopener" href="https://ebpf.io/projects/#bpftrace">bpftrace <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>等项目间接使用，这些项目在 eBPF 之上提供了抽象，不需要直接编写程序，而是提供指定基于意图的定义的能力，然后用 eBPF 实现。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-05-07_01-07-08.png" alt="nipaste_2024-05-07_01-07-0"></p>
<p>如果不存在更高级别的抽象，则需要直接编写程序。Linux 内核希望 eBPF 程序以字节码的形式加载。虽然当然可以直接编写字节码，但更常见的开发实践是利用<a class="link" target="_blank" rel="noopener" href="https://llvm.org/">LLVM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>等编译器套件将伪 C 代码编译为 eBPF 字节码。</p>
<h3 id="Loder-Verifier-architecture"><a href="#Loder-Verifier-architecture" class="headerlink" title="Loder & Verifier architecture"></a>Loder &amp; Verifier architecture</h3><p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-05-07_01-07-09.png" alt="nipaste_2024-05-07_01-07-0"></p>
<p>上图展示了一个 ebpf 程序从加载到验证结束经过 JIT 编译，从而在内核中发挥作用。</p>
<h3 id="eBPF-verifier"><a href="#eBPF-verifier" class="headerlink" title="eBPF verifier"></a>eBPF verifier</h3><p>eBPF 程序的安全是通过<strong>两个步骤</strong>来保证的：</p>
<ul>
<li><strong>首先做一次 DAG 检查</strong>，确保没有循环，并执行其他 CFG validation。特别地，这会检查程序中是否有 无法执行到的指令（unreachable instructions，虽然 cBPF checker 是允许的）。</li>
<li><strong>第二步是从程序的第一条指令开始，遍历所有的可能路径</strong>。这一步会模拟执行每一条指令，在过程中观察寄存器和栈的状态变化。</li>
</ul>
<p>Verifier 的功能如下</p>
<p><strong>1. 模拟执行</strong></p>
<ul>
<li>程序开始时，<strong>R1 中存放的是上下文指针</strong>（<code>ctx</code>），类型是 <code>PTR_TO_CTX</code>。<ul>
<li>接下来，如果校验器看到 <strong>R2=R1，那 R2 的类型也变成了 PTR_TO_CTX</strong>，并且接下来就能用在表达式的右侧。</li>
<li>如果 R1=PTR_TO_CTX 接下来的指令是 <strong>R2=R1+R1，那 R2=SCALAR_VALUE</strong>， 因为<strong>两个合法指针相加，得到的是一个非法指针</strong>。（在 “secure” 模式下， 校验器会拒绝任何类型的指针运算，以确保内核地址不会泄露给 unprivileged users）。</li>
</ul>
</li>
<li><strong>从来没有写入过数据的寄存器是不可读的</strong>，例如：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R0 = R2</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将会被拒绝，因为程序开始之后，R2 还没有初始化过。</li>
<li>内核函数<strong>执行完成后，R1-R5 将被重置为不可读状态</strong>，R0 保存函数的返回值。</li>
<li>由于 R6-R9 是被调用方（callee）保存的，因此它们的状态在函数调用结束之后还是有效的。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov  R6 = 1</span><br><span class="line">bpf_call foo</span><br><span class="line">bpf_mov  R0 = R6</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure></div>

<p>以上程序是合法的。如果换成了 <code>R0 = R1</code>，就会被拒绝，测试如下（将示例1中的命令简单修改）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">test_bpf_prog</span>[] =</span> {</span><br><span class="line">    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, BPF_REG_1, BPF_REG_0, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>上面的命令中我们直接使用未初始化的 REG_0 赋值给 REG_1 是错误的</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-07-28_23-14-23.png" alt="nipaste_2024-07-28_23-14-2"></p>
<p><code>R0 !read_ok</code> 表示验证器认为寄存器R0的值尚未初始化或不能安全读取。这通常发生在程序试图读取未正确初始化的寄存器时。</p>
<p><strong>注意事项：</strong>从上图可以看到程序开始时，R1 类型是 <code>PTR_TO_CTX</code>（指向通用类型 <code>struct bpf_context</code> 的指针）</p>
<p><strong>2. load/store 指令检查</strong></p>
<p>load/store 指令只有当<strong>寄存器类型合法时</strong>才能执行，这里的类型包括 <code>PTR_TO_CTX</code>、<code>PTR_TO_MAP</code>、<code>PTR_TO_STACK</code>。会对它们做边界和对齐检查。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R1 = 1</span><br><span class="line">bpf_mov R2 = 2</span><br><span class="line">bpf_xadd *(u32 *)(R1 + 3) += R2</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure></div>

<p>将会被拒，因为执行到第三行时，R1 并不是一个合法的指针类型。</p>
<p><strong>3. 定制化校验器，限制程序只能访问 <code>ctx</code> 特定字段</strong></p>
<p>程序开始时，R1 类型是 <code>PTR_TO_CTX</code>（指向通用类型 <code>struct bpf_context</code> 的指针）。 可以<strong>通过 callback 定制化校验器</strong>，指定 size 和对齐，来 <strong>限制 eBPF 程序只能访问 ctx 的特定字段</strong>。 例如，下面的指令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_ld R0 = *(u32 *)(R6 + 8)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果 R6=<code>PTR_TO_CTX</code>，通过 <code>is_valid_access()</code> callback，校验器就能知道从 offset 8 处读取 4 个字节的操作是合法的，否则，校验器就会拒绝这个程序。</li>
<li>如果 R6=<code>PTR_TO_STACK</code>，那访问就应该是对齐的，而且在栈空间范围内，即 <code>[-MAX_BPF_STACK, 0)</code>。在这里例子中 offset 是 8，因此校验会失败，因为超出 栈空间边界。</li>
</ul>
<p><strong>4. 读取栈空间</strong></p>
<p>只有程序<strong>向栈空间写入数据后，校验器才允许它从中读取数据</strong>。cBPF 通过 <code>M[0-15]</code> memory slots 执行类似的检查，例如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpf_ld R0 = *(u32 *)(R10 - 4)</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure></div>

<p>是非法程序。因为虽然 R10 是只读寄存器，类型 PTR_TO_STACK 也是合法的，并且 <code>R10 - 4</code> 也在栈边界内，但在这次读取操作之前，并没有往这个位置写入数据。</p>
<p><strong>5. 其他</strong></p>
<ul>
<li><p>指针寄存器（pointer register）spill/fill 操作也会被跟踪，因为 <strong>对一些程序来说，四个 (R6-R9) callee saved registers 显然是不够的</strong>。</p>
</li>
<li><p>可通过 <code>bpf_verifier_ops-&gt;get_func_proto()</code> 来<strong>定制允许执行哪些函数</strong>。 eBPF 校验器会检查寄存器与参数限制是否匹配。调用结束之后，R0 用来存放函数返回值。</p>
</li>
<li><p><strong>函数调用</strong>是扩展 eBPF 程序功能的主要机制，但每种类型的 BPF 程 序能用到的函数是不同的，例如 socket filters 和 tracing 程序。</p>
</li>
<li><p>如果一个函数设计成对 eBPF 可见的，那必须从安全的角度对这个函数进行考量。校验 器会保证调用该函数时，参数都是合法的。</p>
</li>
<li><p>cBPF 中， seccomp 的安全限制与 socket filter 是不同的，它依赖<strong>两个级联的校验器</strong>：</p>
<ul>
<li>首先执行 cBPF verifier，</li>
<li>然后再执行 seccomp verifier</li>
</ul>
<p>而在 <strong>eBPF 中，所有场景都共用一个（可配置的）校验器</strong>。</p>
</li>
</ul>
<p>更多关于 eBPF 校验器的信息，可参考 <a class="link" target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v5.10/kernel/bpf/verifier.c">kernel/bpf/verifier.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="寄存器值跟踪（register-value-tracking）"><a href="#寄存器值跟踪（register-value-tracking）" class="headerlink" title="寄存器值跟踪（register value tracking）"></a>寄存器值跟踪（register value tracking）</h3><p>为保证 eBPF 程序的安全，校验器必须跟踪每个<strong>寄存器</strong>和<strong>栈上每个槽位</strong> （stack slot）值的范围。这是通过 <strong>struct bpf_reg_state</strong> 实现的，定义在 <a class="link" target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v5.10/include/linux/bpf_verifier.h#L43">include/linux/bpf_verifier.h <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>， 它<strong>统一了对标量和指针类型的跟踪</strong>（scalar and pointer values）。</p>
<p>每个<strong>寄存器状态</strong>都有一个<strong>类型</strong>，</p>
<ul>
<li><code>NOT_INIT</code>：该寄存器还未写入数据</li>
<li><code>SCALAR_VALUE</code>：标量值，不可作为指针</li>
<li>指针类型</li>
</ul>
<p><strong>9 种指针类型</strong></p>
<p>依据它们<strong>指向的数据结构类型</strong>，又可以分为：</p>
<ol>
<li><p><code>PTR_TO_CTX</code>：指向 <strong>bpf_context</strong> 的指针。</p>
</li>
<li><p><code>CONST_PTR_TO_MAP</code>：指向 <strong>struct bpf_map</strong> 的指针。 是<strong>常量</strong>（const），因为不允许对这种类型指针进行算术操作。</p>
</li>
<li><p><code>PTR_TO_MAP_VALUE</code>：指向 bpf <strong>map 元素</strong>的指针。</p>
</li>
<li><p><code>PTR_TO_MAP_VALUE_OR_NULL</code>：指向 bpf map 元素的指针，可为 NULL。 <strong>访问 map 的操作</strong>会返回这种类型的指针。<strong>禁止算术操作</strong>。</p>
</li>
<li><p><code>PTR_TO_STACK</code>：帧指针（Frame pointer）。</p>
</li>
<li><p><code>PTR_TO_PACKET</code>：指向 <strong>skb-&gt;data</strong> 的指针。</p>
</li>
<li><p><code>PTR_TO_PACKET_END</code>：指向 <strong>skb-&gt;data + headlen</strong> 的指针。禁止算术操作。</p>
</li>
<li><p><code>PTR_TO_SOCKET</code>：指向 <strong>struct bpf_sock_ops</strong> 的指针，内部有引用计数。</p>
</li>
<li><p><code>PTR_TO_SOCKET_OR_NULL</code>：指向 <strong>struct bpf_sock_ops</strong> 的指针，或 NULL。</p>
<p><strong>socket lookup 操作</strong>会返回这种类型。<strong>有引用计数</strong>， 因此程序在执行结束时，必须通过 socket release 函数释放引用。禁止算术操作。</p>
</li>
</ol>
<p>这些指针都称为 base 指针。</p>
<p><strong>1. 指针偏移（offset）触发寄存器状态更新</strong></p>
<p>实际上，很多有用的指针都是 base 指针加一个 offset（指针算术运算的结果）， 这是通过两方面来个跟踪的：</p>
<ol>
<li>‘fixed offset’（<strong>固定偏移</strong>）：offset 是个常量（例如，立即数）。</li>
<li>‘variable offset’（<strong>可变偏移</strong>）：offset 是个变量。这种类型还用在 SCALAR_VALUE 跟踪中，来跟踪寄存器值的可能范围。</li>
</ol>
<p>校验器对可变 offset 的支持包括：</p>
<ol>
<li>无符号类型：最小和最大值；</li>
<li>有符号类型：最小和最大值；</li>
<li>关于每个 bit 的支持，以 ‘tnum’ 的格式: 一个 u64 ‘mask’ 加一个 u64 ‘value’。</li>
</ol>
<blockquote>
<p><strong>重要总结：</strong>1s in the mask represent bits whose value is unknown; 1s in the value represent bits known to be 1. Bits known to be 0 have 0 in both mask and value; no bit should ever be 1 in both。 例如，如果从内存加载一个字节到寄存器，那该寄存器的<strong>前 56bit 已知是全零</strong>，而<strong>后 8bit 是未知的</strong> —— 表示为 <code>tnum (0x0; 0xff)</code>。如果我们将这个值与 0x40 进行 OR 操作，就得到 <code>(0x40; 0xbf)</code>；如果加 1 就得到 <code>(0x0; 0x1ff)</code>，因为可能的进位操作。</p>
</blockquote>
<p><strong>2. 条件分支触发寄存器状态更新</strong></p>
<p>除了算术运算之外，条件分支也能更新寄存器状态。例如，如果判断一个 SCALAR_VALUE 大于 8，那</p>
<ul>
<li>在 true 分支，这个变量的最小值 <code>umin_value</code>（unsigned minimum value）就是 9；</li>
<li>在 false 分支，它的最大值就是 umax_value of 8。</li>
</ul>
<p><strong>3. 有符号比较触发寄存器状态更新</strong></p>
<p><strong>有符号比较</strong>（BPF_JSGT or BPF_JSGE）也会相应更新有符号变量的最大最小值。</p>
<p>有符合和无符号边界的信息可以结合起来；例如如果一个值先判断小于无 符号 8，后判断大于有符合 4，校验器就会得出结论这个值大于无符号 4，小于有符号 8 ，因为这个边界不会跨正负边界。</p>
<p><strong>4. <code>struct bpf_reg_state</code> 的 <code>id</code> 字段</strong></p>
<p><code>struct bpf_reg_state</code> 结构体有一个 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v5.10/include/linux/bpf_verifier.h#L73"><code>id</code></a> 字段，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// include/linux/bpf_verifier.h</span><br><span class="line"></span><br><span class="line">    /* For PTR_TO_PACKET, used to find other pointers with the same variable</span><br><span class="line">     * offset, so they can share range knowledge.</span><br><span class="line">     * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we</span><br><span class="line">     * came from, when one is tested for != NULL.</span><br><span class="line">     * For PTR_TO_MEM_OR_NULL this is used to identify memory allocation</span><br><span class="line">     * for the purpose of tracking that it's freed.</span><br><span class="line">     * For PTR_TO_SOCKET this is used to share which pointers retain the</span><br><span class="line">     * same reference to the socket, to determine proper reference freeing.</span><br><span class="line">     */</span><br><span class="line">    u32 id;</span><br></pre></td></tr></table></figure></div>

<p>如注释所述，该字段针对不同指针类型有不同用途，下面分别解释。</p>
<p><strong><code>PTR_TO_PACKET</code></strong></p>
<p><code>id</code> 字段对<strong>共享同一 variable offset 的多个 PTR_TO_PACKET 指针</strong> 都是可见的，这对<strong>skb 数据的范围检查</strong>非常重要。举个例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:  A = skb-&gt;data // A 是指向包数据的指针</span><br><span class="line">2:  B = A + var2  // B 是从 A 开始往前移动 var2 得到的地址</span><br><span class="line">3:  A = A + 4     // A 往前移动 4 个字节</span><br></pre></td></tr></table></figure></div>

<p>在这个程序中，寄存器 <strong>A 和 B 将将共享同一个 id</strong>，</p>
<ul>
<li>A 已经从最初地址向前移动了 4 字节（有一个固定偏移 +4），</li>
<li>如果这个边界通过校验了，也就是确认小于 <code>PTR_TO_PACKET_END</code>，那现在 <strong>寄存器 B 将有一个范围至少为 4 字节的可安全访问范围</strong>（这里我也没有理解，明明加了var2，为什么说是至少4字节的可安全访问范围）。</li>
</ul>
<p><strong><code>PTR_TO_MAP_VALUE</code></strong></p>
<p>与上面的用途类似，具体来说：</p>
<ol>
<li>这一字段对共享同一基础指针的多个 PTR_TO_MAP_VALUE 指针可见；</li>
<li>这些指针中，<strong>只要一个指针经验证是非空的，就认为其他指针（副本）都是非空的</strong>（因此减少重复验证开销）；</li>
</ol>
<p>另外，与 range-checking 类似，跟踪的信息（the tracked information）还用于<strong>确保指针访问的正确对齐</strong>。 例如，在大部分系统上，packet 指针都 4 字节对齐之后再加 2 字节。如果一个程序将这个指针加 14（跳过 Ethernet header）然后读取 IHL，并将指针再加上 <code>IHL * 4</code>，最终的指针将有一个 <code>4n + 2</code> 的 variable offset，因此，加 2 （<code>NET_IP_ALIGN</code>） gives a 4-byte alignment，因此通过这个指针进行 word-sized accesses 是安全的。</p>
<p><strong><code>PTR_TO_SOCKET</code></strong></p>
<p>与上面用途类似，只要一个指针验证是非空的，其他共享同一 <code>id</code> 的 PTR_TO_SOCKET 指针就都是非空的；此外， 还<strong>负责跟踪指针的引用</strong>（reference tracking for the pointer）。</p>
<p>PTR_TO_SOCKET 隐式地表示对一个 <code>struct sock</code> 的引用。为确保引用没有泄露，需要强制对引用进行非空（检查）， 如果非空（non-NULL），将合法引用传给 socket release 函数。</p>
<h3 id="直接数据包访问（direct-packet-access）"><a href="#直接数据包访问（direct-packet-access）" class="headerlink" title="直接数据包访问（direct packet access）"></a>直接数据包访问（direct packet access）</h3><p>对于 cls_bpf 和 act_bpf eBPF 程序，校验器允许<strong>直接通过 skb-&gt;data 和 skb-&gt;data_end 指针访问包数据</strong>。</p>
<p><strong>简单例子</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1:  r4 = *(u32 *)(r1 +80)  /* load skb-&gt;data_end */</span><br><span class="line">2:  r3 = *(u32 *)(r1 +76)  /* load skb-&gt;data */</span><br><span class="line">3:  r5 = r3</span><br><span class="line">4:  r5 += 14</span><br><span class="line">5:  if r5 &gt; r4 goto pc+16</span><br><span class="line">R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp # 校验器标记</span><br><span class="line">6:  r0 = *(u16 *)(r3 +12) /* access 12 and 13 bytes of the packet */</span><br></pre></td></tr></table></figure></div>

<p>上面从包数据中加载 2 字节的操作是安全的，因为<strong>程序编写者在第五行主动检查了数据边界</strong>： <code>if (skb-&gt;data + 14 &gt; skb-&gt;data_end) goto err</code>，这意味着能执行到第 6 行时（fall-through case）， R3（<code>skb-&gt;data</code>）至少有 14 字节的直接可访问数据，因此 **校验器将其标记为 R3=pkt(id=0,off=0,r=14)**：</p>
<ul>
<li><code>id=0</code> 表示<strong>没有额外的变量加到这个寄存器上</strong>；</li>
<li><code>off=0</code> 表示<strong>没有额外的常量 offset</strong>；</li>
<li><code>r=14</code> 表示<strong>安全访问的范围</strong>，即 <code>[R3, R3+14)</code> 指向的字节范围都是 OK 的。</li>
</ul>
<p>这里注意 **R5 被标记为 R5=pkt(id=0,off=14,r=14)**，</p>
<ul>
<li>它也指向包数据，但<strong>常量 14 加到了寄存器</strong>，因为它执行的是 <code>skb-&gt;data + 14</code>，</li>
<li>因此可访问的范围是 <code>[R5, R5 + 14 - 14)</code>，也就是 0 个字节。</li>
</ul>
<p><strong>复杂例子</strong></p>
<p>下面是个更复杂一些的例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R0=inv1 R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp</span><br><span class="line">6:   r0 = *(u8 *)(r3 +7) /* load 7th byte from the packet */</span><br><span class="line">7:   r4 = *(u8 *)(r3 +12)</span><br><span class="line">8:   r4 *= 14</span><br><span class="line">9:   r3 = *(u32 *)(r1 +76) /* load skb-&gt;data */</span><br><span class="line">10:  r3 += r4</span><br><span class="line">11:  r2 = r1</span><br><span class="line">12:  r2 &lt;&lt;= 48</span><br><span class="line">13:  r2 &gt;&gt;= 48</span><br><span class="line">14:  r3 += r2</span><br><span class="line">15:  r2 = r3</span><br><span class="line">16:  r2 += 8</span><br><span class="line">17:  r1 = *(u32 *)(r1 +80) /* load skb-&gt;data_end */</span><br><span class="line">18:  if r2 &gt; r1 goto pc+2</span><br><span class="line">R0=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) R1=pkt_end R2=pkt(id=2,off=8,r=8) R3=pkt(id=2,off=0,r=8) R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)) R5=pkt(id=0,off=14,r=14) R10=fp</span><br><span class="line">19:  r1 = *(u8 *)(r3 +4)</span><br></pre></td></tr></table></figure></div>

<p><strong>校验器标记信息解读</strong></p>
<p>第 18 行之后，寄存器 R3 的状态是 <code>R3=pkt(id=2,off=0,r=8)</code>，</p>
<ul>
<li><code>id=2</code> 表示<strong>之前已经跟踪到两个 r3 += rX 指令</strong>，因此 r3 指向某个包内的某个 offset，由于程序员在 18 行已经做了 <code>if (r3 + 8 &gt; r1) goto err</code> 检查，因此<strong>安全范围</strong>是 <code>[R3, R3 + 8)</code>。</li>
<li>校验器<strong>只允许对 packet 寄存器执行 add/sub</strong> 操作。其他操作会将寄存器状态设为 <strong>SCALAR_VALUE，这个状态是不允许执行 direct packet access 的</strong>。</li>
</ul>
<p>操作 <code>r3 += rX</code> <strong>可能会溢出，变得比起始地址 skb-&gt;data 还小</strong>，校验器必须要能检查出这种情况。 因此当它看到 <code>r3 += rX</code> 指令并且 rX 比 16bit 值还大时，接下来的任何将 r3 与 <code>skb-&gt;data_end</code> 对比的操作都<strong>不会返回范围信息</strong>，因此尝试通过 这个指针读取数据的操作都会收到 <strong>invalid access to packet</strong> 错误。 例如，</p>
<ul>
<li><code>r4 = *(u8 *)(r3 +12)</code> 之后，r4 的状态是 <code>R4=inv(id=0,umax_value=255,var_off=(0x0; 0xff))</code>，意思是 寄存器的 upper 56 bits 肯定是 0，但对于低 8bit 信息一无所知。 在执行完 <code>r4 *= 14</code> 之后，状态变成 <code>R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe))</code>，因为一个 8bit 值乘以 14 之后， 高 52bit 还是 0，此外最低 bit 位为 0，因为 14 是偶数。</li>
<li>类似地，<code>r2 &gt;&gt;= 48</code> 使得 <code>R2=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff))</code>，因为移位是无符号扩展。 这个逻辑在函数 <code>adjust_reg_min_max_vals()</code> 中实现，它又会调用<ul>
<li><code>adjust_ptr_min_max_vals()</code></li>
<li><code>adjust_scalar_min_max_vals()</code></li>
</ul>
</li>
</ul>
<h3 id="Pruning（剪枝）"><a href="#Pruning（剪枝）" class="headerlink" title="Pruning（剪枝）"></a>Pruning（剪枝）</h3><p>校验器实际上<strong>并不会模拟执行程序的每一条可能路径</strong>。</p>
<p>对于每个新条件分支：校验器首先会查看它自己当前已经跟踪的所有状态。如果这些状态已经覆盖到这个新分支，该分支就会被剪掉（pruned）—— 也就是说之前的状态已经被接受 （previous state was accepted）能证明当前状态也是合法的。</p>
<p>举个例子：</p>
<ol>
<li>当前的状态记录中，r1 是一个 packet-pointer</li>
<li>下一条指令中，r1 仍然是 packet-pointer with a range as long or longer and at least as strict an alignment，那 r1 就是安全的。</li>
</ol>
<p>类似的，如果 r2 之前是 <code>NOT_INIT</code>，那就说明之前任何代码路径都没有用到这个寄存器 ，因此 r2 中的任何值（包括另一个 NOT_INIT）都是安全的。</p>
<p>实现在 <code>regsafe()</code> 函数。</p>
<p>Pruning 过程不仅会看寄存器，还会看栈（及栈上的 spilled registers）。 只有证明二者都安全时，这个分支才会被 prune。这个过程实现在 <code>states_equal()</code> 函数。</p>
<blockquote>
<p>这一部分还未理解，什么叫这些状态已经覆盖到这个新分支</p>
</blockquote>
<h3 id="helper-function"><a href="#helper-function" class="headerlink" title="helper function"></a>helper function</h3><p>eBPF 程序无法调用任意内核函数，这样做会将 eBPF 程序绑定到特定内核版本，并使程序的兼容性变得复杂。相反，eBPF 程序可以调用辅助函数，这是内核提供的一个众所周知且稳定的 API。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/Snipaste_2024-05-07_01-07-11.png" alt="nipaste_2024-05-07_01-07-1"></p>
<p>辅助函数一直再发展，下面是一些辅助函数的例子：</p>
<ul>
<li>Generate random numbers</li>
<li>Get current time &amp; date</li>
<li>eBPF map access</li>
<li>Get process/cgroup context</li>
<li>Manipulate network packets and forwarding logic</li>
</ul>
<h3 id="理解-eBPF-校验器提示信息"><a href="#理解-eBPF-校验器提示信息" class="headerlink" title="理解 eBPF 校验器提示信息"></a>理解 eBPF 校验器提示信息</h3><p>提供几个不合法的 eBPF 程序及相应校验器报错的例子。</p>
<p><strong>1. 程序包含无法执行到的指令</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct bpf_insn prog[] = {</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unreachable insn 1</span><br></pre></td></tr></table></figure></div>

<p><strong>2. 程序读取未初始化的寄存器</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_0, BPF_REG_2),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0: (bf) r0 = r2</span><br><span class="line">R2 !read_ok</span><br></pre></td></tr></table></figure></div>

<p><strong>3. 程序退出前未设置 R0 寄存器</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_1),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: (bf) r2 = r1</span><br><span class="line">1: (95) exit</span><br><span class="line">R0 !read_ok</span><br></pre></td></tr></table></figure></div>

<p><strong>4. 程序访问超出栈空间</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, 8, 0),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0: (7a) *(u64 *)(r10 +8) = 0</span><br><span class="line">invalid stack off=8 size=8</span><br></pre></td></tr></table></figure></div>

<p><strong>5. 未初始化栈内元素，就传递该栈地址</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error::</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: (bf) r2 = r10</span><br><span class="line">1: (07) r2 += -8</span><br><span class="line">2: (b7) r1 = 0x0</span><br><span class="line">3: (85) call 1</span><br><span class="line">invalid indirect read from stack off -8+0 size 8</span><br></pre></td></tr></table></figure></div>

<p><strong>6. 程序执行 <code>map_lookup_elem()</code> 传递了非法的 <code>map_fd</code></strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">1: (bf) r2 = r10</span><br><span class="line">2: (07) r2 += -8</span><br><span class="line">3: (b7) r1 = 0x0</span><br><span class="line">4: (85) call 1</span><br><span class="line">fd 0 is not pointing to valid bpf_map</span><br></pre></td></tr></table></figure></div>

<p><strong>7. 程序未检查 <code>map_lookup_elem()</code> 的返回值是否为空就开始使用</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">1: (bf) r2 = r10</span><br><span class="line">2: (07) r2 += -8</span><br><span class="line">3: (b7) r1 = 0x0</span><br><span class="line">4: (85) call 1</span><br><span class="line">5: (7a) *(u64 *)(r0 +0) = 0</span><br><span class="line">R0 invalid mem access 'map_value_or_null'</span><br></pre></td></tr></table></figure></div>

<p><strong>8. 程序访问 map 内容时使用了错误的字节对齐</strong></p>
<p>程序虽然检查了 <code>map_lookup_elem()</code> 返回值是否为 NULL，但接下来使用了错误的对齐：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),</span><br><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_0, 4, 0),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">1: (bf) r2 = r10</span><br><span class="line">2: (07) r2 += -8</span><br><span class="line">3: (b7) r1 = 1</span><br><span class="line">4: (85) call 1</span><br><span class="line">5: (15) if r0 == 0x0 goto pc+1</span><br><span class="line"> R0=map_ptr R10=fp</span><br><span class="line">6: (7a) *(u64 *)(r0 +4) = 0</span><br><span class="line">misaligned access off 4 size 8</span><br></pre></td></tr></table></figure></div>

<p><strong>9. 程序在 fallthrough 分支中使用了错误的字节对齐访问 map 数据</strong></p>
<p>程序检查了 <code>map_lookup_elem()</code> 返回值是否为 NULL，在 <code>if</code> 分支中使用了正确的字节对齐， 但在 fallthrough 分支中使用了错误的对齐：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),</span><br><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),</span><br><span class="line">BPF_EXIT_INSN(),</span><br><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 1),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">1: (bf) r2 = r10</span><br><span class="line">2: (07) r2 += -8</span><br><span class="line">3: (b7) r1 = 1</span><br><span class="line">4: (85) call 1</span><br><span class="line">5: (15) if r0 == 0x0 goto pc+2</span><br><span class="line"> R0=map_ptr R10=fp</span><br><span class="line">6: (7a) *(u64 *)(r0 +0) = 0</span><br><span class="line">7: (95) exit</span><br><span class="line"></span><br><span class="line">from 5 to 8: R0=imm0 R10=fp</span><br><span class="line">8: (7a) *(u64 *)(r0 +0) = 1</span><br><span class="line">R0 invalid mem access 'imm'</span><br></pre></td></tr></table></figure></div>

<p><strong>10. 程序执行 <code>sk_lookup_tcp()</code>，未检查返回值就直接将其置 NULL</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_IMM(BPF_REG_2, 0),</span><br><span class="line">BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -8),</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_3, 4),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_4, 0),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_5, 0),</span><br><span class="line">BPF_EMIT_CALL(BPF_FUNC_sk_lookup_tcp),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, 0),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: (b7) r2 = 0</span><br><span class="line">1: (63) *(u32 *)(r10 -8) = r2</span><br><span class="line">2: (bf) r2 = r10</span><br><span class="line">3: (07) r2 += -8</span><br><span class="line">4: (b7) r3 = 4</span><br><span class="line">5: (b7) r4 = 0</span><br><span class="line">6: (b7) r5 = 0</span><br><span class="line">7: (85) call bpf_sk_lookup_tcp#65</span><br><span class="line">8: (b7) r0 = 0</span><br><span class="line">9: (95) exit</span><br><span class="line">Unreleased reference id=1, alloc_insn=7</span><br></pre></td></tr></table></figure></div>

<p>这里的信息提示是 socket reference 未释放，说明 <code>sk_lookup_tcp()</code> 返回的是一个非空指针， 直接置空导致这个指针再也无法被解引用。</p>
<p><strong>11. 程序执行 <code>sk_lookup_tcp()</code> 但未检查返回值是否为空</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_IMM(BPF_REG_2, 0),</span><br><span class="line">BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -8),</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_3, 4),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_4, 0),</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_5, 0),</span><br><span class="line">BPF_EMIT_CALL(BPF_FUNC_sk_lookup_tcp),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure></div>

<p>Error:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0: (b7) r2 = 0</span><br><span class="line">1: (63) *(u32 *)(r10 -8) = r2</span><br><span class="line">2: (bf) r2 = r10</span><br><span class="line">3: (07) r2 += -8</span><br><span class="line">4: (b7) r3 = 4</span><br><span class="line">5: (b7) r4 = 0</span><br><span class="line">6: (b7) r5 = 0</span><br><span class="line">7: (85) call bpf_sk_lookup_tcp#65</span><br><span class="line">8: (95) exit</span><br><span class="line">Unreleased reference id=1, alloc_insn=7</span><br></pre></td></tr></table></figure></div>

<p>这里的信息提示是 socket reference 未释放，说明 <code>sk_lookup_tcp()</code> 返回的是一个非空指针， 直接置空导致这个指针再也无法被解引用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Pruning 这一部分暂未理解</p>

        </div>

        
            <div class="post-copyright-info my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> ebpf Basic Knowledge</li>
        <li><strong>Author:</strong> henry</li>
        <li><strong>Created at
                :</strong> 2025-02-10 21:26:52</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-02-10 21:31:21
            </li>
        
        <li>
            <strong>Link:</strong> https://henrymartin262.github.io/2025/02/10/ebpf_study/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/ebpf/">#ebpf</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2025/02/10/netlink/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Netlink Basic Knowledge</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container pjax">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail']
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">ebpf Basic Knowledge</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#eBPF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-text">eBPF学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="nav-text">基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#verifier"><span class="nav-text">verifier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ebpf-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">ebpf 虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E6%8C%87%E4%BB%A4%E4%B8%8E-eBPF-%E7%A8%8B%E5%BA%8F"><span class="nav-text">eBPF 指令与 eBPF 程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-map"><span class="nav-text">eBPF map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bpf-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">bpf 系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bpf-attr-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">bpf_attr 结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-text">eBPF 指令格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-text">算术 &amp; 跳转指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Load-Store-%E6%8C%87%E4%BB%A4"><span class="nav-text">Load &amp; Store 指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ALU-Instructions"><span class="nav-text">ALU Instructions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#64-bit"><span class="nav-text">64-bit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-bit"><span class="nav-text">32-bit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Byteswap-instructions"><span class="nav-text">Byteswap instructions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Instructions"><span class="nav-text">Memory Instructions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Branch-Instructions"><span class="nav-text">Branch Instructions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="nav-text">示例1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#raw-eBPF-map-%E4%BD%BF%E7%94%A8"><span class="nav-text">raw eBPF map 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-eBPF-map"><span class="nav-text">创建 eBPF map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0-eBPF-map"><span class="nav-text">更新 eBPF map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-eBPF-map-%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="nav-text">在 eBPF map 中查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-eBPF-map"><span class="nav-text">遍历 eBPF map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4-eBPF-map-%E6%95%B0%E6%8D%AE"><span class="nav-text">删除 eBPF map 数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%80%E6%AF%81-eBPF-map"><span class="nav-text">销毁 eBPF map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="nav-text">示例2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-text">拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Loder-Verifier-architecture"><span class="nav-text">Loder &amp; Verifier architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-verifier"><span class="nav-text">eBPF verifier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC%E8%B7%9F%E8%B8%AA%EF%BC%88register-value-tracking%EF%BC%89"><span class="nav-text">寄存器值跟踪（register value tracking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%8C%85%E8%AE%BF%E9%97%AE%EF%BC%88direct-packet-access%EF%BC%89"><span class="nav-text">直接数据包访问（direct packet access）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pruning%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89"><span class="nav-text">Pruning（剪枝）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#helper-function"><span class="nav-text">helper function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3-eBPF-%E6%A0%A1%E9%AA%8C%E5%99%A8%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="nav-text">理解 eBPF 校验器提示信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">henry</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.6</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/libs/anime.min.js"></script>

        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


    <div id="aplayer"></div>

<script src="/js/libs/APlayer.min.js"></script>


<script src="/js/plugins/aplayer.js"></script>


</body>
</html>
