<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="henry">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2024/07/30/solidity_study/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="在线智能合约环境：https:&#x2F;&#x2F;remix.ethereum.org&#x2F;  Referencehttps:&#x2F;&#x2F;binschool.app&#x2F;  基本结构使用solidity编写的简单的智能合约 12345678910&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract HelloWorld &#123;    string he">
<meta property="og:type" content="article">
<meta property="og:title" content="blockchain solidity基础">
<meta property="og:url" content="http://example.com/2024/07/30/solidity_study/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在线智能合约环境：https:&#x2F;&#x2F;remix.ethereum.org&#x2F;  Referencehttps:&#x2F;&#x2F;binschool.app&#x2F;  基本结构使用solidity编写的简单的智能合约 12345678910&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract HelloWorld &#123;    string he">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_17-15-19.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_17-27-34.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_17-30-34.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_17-41-11.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_17-48-35.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_17-59-51.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-00-27.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-24-28.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-29-30.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-37-02.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-43-08.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-47-22.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-49-21.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_20-52-45.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_21-02-25.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-29_21-04-55.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-30_10-43-18.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-30_10-44-15.png">
<meta property="og:image" content="http://example.com/images/Snipaste_2024-07-30_11-00-34.png">
<meta property="article:published_time" content="2024-07-30T03:38:55.791Z">
<meta property="article:modified_time" content="2024-07-30T03:40:32.783Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="blockchain，solidity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Snipaste_2024-07-29_17-15-19.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/icon.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/icon.png">
    <!--- Page Info-->
    
    <title>
        
            blockchain solidity基础 -
        
        Henry Martin
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left"},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-we3z86.webp","dark":"/images/wallhaven-6degr6.webp"},"title":"Welcome To Henry's Blog","subtitle":{"text":["a pwner from polaris"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/henrymartin262","instagram":"https://instagram.com","zhihu":"https://www.zhihu.com/","twitter":"https://twitter.com","email":"1551022913@qq.cmo"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":true,"type":"fixed","audios":[{"name":"Something Just Like This","artist":"Coldplay","url":"https://evan.beee.top/music/Something%20Just%20Like%20This%20-%20The%20Chainsmokers%E3%80%81Coldplay.mp3","cover":"https://evan.beee.top/music/covers/Something_Just_Like_This.png"}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.5.6","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Categories":{"path":"/categories/","icon":"fa-regular fa-folder"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"About":{"icon":"fa-regular fa-user","submenus":{"Links":"/links/","Github":"https://github.com/henrymartin262","Blog":"https://henrymartin262.github.io"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/11/24 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Henry Martin
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-folder"></i>
                                        
                                        CATEGORIES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        TAGS
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        ABOUT&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/links/">LINKS
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/henrymartin262">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://henrymartin262.github.io">BLOG
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/categories/"  >
                             
                                
                                    <i class="fa-regular fa-folder"></i>
                                
                                CATEGORIES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/tags"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                TAGS
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                ABOUT&nbsp;<i class="group-hover:rotate-180 transition-transform fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="/links/">LINKS</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://github.com/henrymartin262">GITHUB</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://henrymartin262.github.io">BLOG</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                
                
                <img src="/images/Snipaste_2024-07-30_11-38-39.png" alt="blockchain solidity基础" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75"/>
                
                <div class="w-full flex items-center absolute bottom-0 justify-start">
                    <h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-bold backdrop-blur-lg rounded-xl border border-border-color ">blockchain solidity基础</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/henry.png">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">henry</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-07-30 11:38:55</span>
        <span class="mobile">2024-07-30 11:38:55</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-07-30 11:40:32</span>
            <span class="mobile">2024-07-30 11:40:32</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/blockchain/">blockchain</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/blockchain/solidity/">solidity</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/blockchain%EF%BC%8Csolidity/">blockchain，solidity</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>在线智能合约环境：<a class="link"   target="_blank" rel="noopener" href="https://remix.ethereum.org/" >https://remix.ethereum.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   target="_blank" rel="noopener" href="https://binschool.app/" >https://binschool.app/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>使用<code>solidity</code>编写的简单的智能合约</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    string hello = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) public view <span class="title function_">returns</span>(<span class="params">string memory</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一个典型的智能合约，通常由 4 个部分组成，分别是：<code>声明部分</code>、<code>合约定义部分</code>、<code>状态变量部分</code> 和 <code>函数部分</code>。其中，<code>状态变量部分</code> 和 <code>函数部分</code> 是智能合约的主体。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_17-15-19.png"
                      alt="nipaste_2024-07-29_17-15-1"
                ></p>
<h2 id="solidity-基本数据类型"><a href="#solidity-基本数据类型" class="headerlink" title="solidity 基本数据类型"></a>solidity 基本数据类型</h2><p>在 <code>Solidity</code> 中，数据可分为两种类型：<code>基础类型</code> 和 <code>复合类型</code>。</p>
<p><code>基础类型</code> 包括：整型、布尔型、地址型、字节型、浮点型、枚举型等。</p>
<p><code>复合类型</code> 包括：数组、映射、结构体等。复合类型是由基础类型组合而成，它比基础类型略微复杂。</p>
<p><strong>注意：</strong>数据类型还有其它的分类方法，比如按照数据在传递和使用时的特征不同，又可以分为 <code>值类型（value types）</code> 和 <code>引用类型（reference types）</code> 两大类。</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无符号整型： uint 的内部存储长度是 256 位</span></span><br><span class="line">uint ucount = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 有符号整型： int 的内部存储长度是256位</span></span><br><span class="line">int count = -<span class="number">1</span>; </span><br><span class="line"><span class="comment">//如果要表示的数字位数过长，或者需要按照特定位数进行分组</span></span><br><span class="line">uint num1 = <span class="number">1000_000_000</span>;</span><br><span class="line">uint num2 = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line">比如：<span class="number">10</span> 的 <span class="number">18</span> 次方，也就是 <span class="number">1</span> 后面跟着 <span class="number">18</span> 个 <span class="number">0</span>，可以简写为 <span class="number">10e18</span>。</span><br></pre></td></tr></table></figure></div>

<p><strong>算数运算符</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">IntegerCompare</span> &#123;</span><br><span class="line">  int public a = <span class="number">2</span>;</span><br><span class="line">  int public b = <span class="number">3</span>;</span><br><span class="line">  int public a_add_b = a + b; <span class="comment">// a_add_b = 5</span></span><br><span class="line">  int public a_sub_b = a - b; <span class="comment">// a_sub_b = -1</span></span><br><span class="line">  int public a_mul_b = a * b; <span class="comment">// a_mul_b = 6</span></span><br><span class="line">  int public a_div_b = a / b; <span class="comment">// a_div_b = 0</span></span><br><span class="line">  int public a_mod_b = a % b; <span class="comment">// a_mod_b = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>点击部署的合约中变量 <code>a_add_b</code>、<code>a_sub_b</code>、<code>a_mul_b</code>、<code>a_div_b</code>、<code>a_mod_b</code>，就会显示运算后的变量值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_17-27-34.png"
                      alt="nipaste_2024-07-29_17-27-3"
                ></p>
<p>除了 uint 和 int 外，<code>Solidity</code> 中按照存储长度，还定义了一系列特定长度的 <code>整型</code>。它们的长度从 8 位一直到 256 位，按照 8 的倍数递增。</p>
<p><strong>无符号整型</strong> uint8、uint16、uint24、uint32……uint256，</p>
<p><strong>有符号整型</strong> int8、int16、int24、int32……int256</p>
<p><strong>获取某种整型的最大值和最小值</strong>，可以使用 <code>type</code> 函数。这在有些 <code>ERC20</code> 代币合约中会用到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_17-30-34.png"
                      alt="nipaste_2024-07-29_17-30-3"
                ></p>
<p><strong>注意事项：</strong>如果不对变量初始化，默认值为 0</p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">BoolOps</span> &#123;</span><br><span class="line">  bool public a = <span class="literal">true</span>;</span><br><span class="line">  bool public b = <span class="literal">false</span>;</span><br><span class="line">  bool public not_a = !a;  <span class="comment">// not_a = false</span></span><br><span class="line">  bool public a_and_b = (a &amp;&amp; b); <span class="comment">// a_and_b = false</span></span><br><span class="line">  bool public a_or_b = (a || b); <span class="comment">// a_or_b = true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 遵循短路（ short-circuiting ）规则。</p>
<p>布尔型变量默认值为 false</p>
<h3 id="地址型"><a href="#地址型" class="headerlink" title="地址型"></a>地址型</h3><p><code>地址型</code> 是 <code>Solidity</code> 中常用的数据类型之一，用来<strong>存储以太坊中的账户地址</strong>，它使用关键字 <code>address</code> 来声明。</p>
<p><code>地址型</code> 变量的<strong>内部存储长度为160位，也就是20个字节</strong>，通常使用一个十六进制字符串来表示，并以前缀 <code>0x</code> 开头</p>
<p>账户地址是通过公钥按照一定算法计算得到的。</p>
<p>计算过程如下：</p>
<ul>
<li>首先，将未压缩格式的公钥作为输入值，使用 <strong>keccak-256 哈希算法</strong>，生成了一个256位的哈希值。</li>
<li>然后，<strong>截取256位哈希值右边的160位</strong>作为账户地址。</li>
<li>最后，为了便于显示，账户地址使用<strong>十六进制字符串来表示</strong>，这个字符串的长度为40（ 1个字节由两个16进制字符来表示），并以前缀 <code>0x</code> 开头。</li>
</ul>
<p>地址之间可以进行比较运算，使用的操作符有：<code>==</code>、<code>!=</code>、 <code>&lt;=</code>、 <code>&lt;</code>、<code>&gt;=</code>、<code>&gt;</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT </span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract <span class="title class_">AddressCompare</span> &#123;</span><br><span class="line">    address address1 = <span class="number">0xB2D02Ac73b98DA8baF7B8FD5ACA31430Ec7D4429</span>;</span><br><span class="line">    address address2 = <span class="number">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">compareAddresses</span>(<span class="params"></span>) public view returns (bool) &#123;</span><br><span class="line">        <span class="keyword">return</span> (address1 == address2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面这个程序比较两个账户地址是否相同，可以看到在上面的例子中，两个值并不相同，最终返回值为 false</p>
<p><strong>地址属性和方法</strong></p>
<p><code>地址</code> 具有 .balance 属性，用于返回该账户中以太坊的余额，这也是 <code>地址</code> 最常用的方法</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT </span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract <span class="title class_">AddressBalance</span> &#123; </span><br><span class="line">    address account = <span class="number">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getBalance</span>(<span class="params"></span>) public view <span class="title function_">returns</span>(<span class="params">uint</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> account.<span class="property">balance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_17-41-11.png"
                      alt="nipaste_2024-07-29_17-41-1"
                ></p>
<p><code>地址</code> 也经常用于转账，我们可以使用地址的 <code>.transfer()</code> 和 <code>.send()</code> 方法进行转账。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT </span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract <span class="title class_">AddressTransfer</span> &#123; </span><br><span class="line">    address account = <span class="number">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transferETH</span>(<span class="params"></span>) public &#123;</span><br><span class="line">        <span class="title function_">payable</span>(account).<span class="title function_">transfer</span>(<span class="number">1</span> ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><code>浮点型</code> 共有两种：<code>fixed</code> 和 <code>ufixed</code>，分别代表 <strong>有符号定长浮点数</strong> 和 <strong>无符号定长浮点数</strong>。</p>
<p>还定义了一系列特定长度的浮点数，分别使用关键字 <code>fixedMxN</code> 和 <code>ufixedMxN</code> 表示，其中 M 表示该类型占用的总位数，N 表示可用的小数位数。</p>
<p>M 可以取值 8 到 256 位，但必须能够被 8 整除；N 可以是从 0 到 80 之间的任意数。</p>
<p><code>fixed</code> 和 <code>ufixed</code> 分别是 fixed128x18 和 ufixed128x18 的别名。</p>
<p><strong>示例</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点型常量可以直接赋值</span></span><br><span class="line">fixed constant <span class="variable constant_">PI</span> = <span class="number">3.14159265</span>;</span><br><span class="line"><span class="comment">// 不能给浮点型变量直接赋值</span></span><br><span class="line">fixed a = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_17-48-35.png"
                      alt="nipaste_2024-07-29_17-48-3"
                ></p>
<p><strong>重要</strong></p>
<p>在 <code>Solidity</code> 中，<code>wei</code>是以太币的基本计量单位，也是默认的计量单位，而不是 <code>ETH</code>。</p>
<p>1 个以太币 <code>ETH</code> 等于 10**18（10的18次方）<code>wei</code>。</p>
<p>在 <code>Solidity</code> 中，对某地址 address 进行一笔转账，可以使用如下的方式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payable(address).transfer(100);</span><br></pre></td></tr></table></figure></div>

<p>表明向 address 转了 100 wei，而不是100个比特币。</p>
<h3 id="枚举型"><a href="#枚举型" class="headerlink" title="枚举型"></a>枚举型</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型</span></span><br><span class="line">enum gender &#123;male, female&#125;</span><br><span class="line"><span class="comment">// 使用枚举型</span></span><br><span class="line">gender a = gender.<span class="property">male</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项：</strong></p>
<ul>
<li>枚举列表不能为空，至少要包含一个成员，否则编译器将会报错</li>
<li>定义枚举型的语句，后面不需要跟着分号。一般大括号的后面都不需要跟着分号，如果跟着分号，编译器会报错</li>
<li>枚举型只能在全局空间内声明，不能在函数内声明。通常放在状态变量前面的位置声明</li>
</ul>
<p>枚举型在编译后就会转换为无符号整数 <code>uint8</code>，在 <code>Solidity</code> 中，枚举值可以转换为整数，它的第一个成员的值默认是 0，后面的值依次递增。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum status &#123;normal, deleted&#125;</span><br><span class="line">uint8 a = <span class="title function_">uint8</span>(status.<span class="property">normal</span>) <span class="comment">// a = 0</span></span><br><span class="line">uint8 b = <span class="title function_">uint8</span>(status.<span class="property">deleted</span>) <span class="comment">// b = 1</span></span><br></pre></td></tr></table></figure></div>

<p>下面是一个类型转换的例子</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT </span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract <span class="title class_">EnumOps</span> &#123;</span><br><span class="line">    <span class="comment">// 定义枚举型</span></span><br><span class="line">    enum gender &#123;male, female&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用枚举型声明状态变量</span></span><br><span class="line">    gender private myGender = gender.<span class="property">female</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数内使用枚举类型</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">useEnum</span>(<span class="params"></span>) public <span class="title function_">returns</span>(<span class="params">gender</span>) &#123;</span><br><span class="line">        gender t = myGender;</span><br><span class="line">        myGender =  gender.<span class="property">male</span>;</span><br><span class="line">        <span class="keyword">return</span> t; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 枚举型用作返回值</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">returnEnum</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">gender</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gender.<span class="property">female</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举值转换为整型</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">convertInt</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">uint</span>(gender.<span class="property">female</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整型转换为枚举型</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">convertEnum</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">gender</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">gender</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_17-59-51.png"
                      alt="nipaste_2024-07-29_17-59-5"
                ></p>
<h2 id="solidity-变量"><a href="#solidity-变量" class="headerlink" title="solidity 变量"></a>solidity 变量</h2><p><code>Solidity</code> 提供了 3 种类型的变量：<code>状态变量</code>、<code>局部变量</code>、<code>全局变量</code>。</p>
<p><strong>状态变量</strong></p>
<p>状态变量是指在智能合约中声明的<strong>持久化存储的变量</strong>。它存在于合约的整个生命周期，直到合约被销毁。</p>
<p>状态变量的<strong>变动是要记录在区块链上的</strong>，永久存储，也就是通常所说的“数据上链”。</p>
<p>状态变量在<strong>合约的不同函数之间共享</strong>，可以通过调用函数来读取或修改它的数据值。</p>
<p>状态变量类似于其它编程语言中“类”的成员变量。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">StatusVar</span> &#123;</span><br><span class="line">   uint256 myStatus = <span class="number">1</span>;  <span class="comment">// 声明状态变量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">getStatus</span>(<span class="params"></span>) public view <span class="title function_">returns</span>(<span class="params">uint256</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> myStatus;   <span class="comment">// 使用状态变量</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>局部变量</strong></p>
<p>局部变量如上代码中所示，不难理解其作用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">LocalVar</span> &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">uint256</span>)&#123;</span><br><span class="line">      uint256 a = <span class="number">1</span>;  <span class="comment">// 声明局部变量 a</span></span><br><span class="line">      uint256 b = <span class="number">2</span>;  <span class="comment">// 声明局部变量 b</span></span><br><span class="line">      uint256 result = a + b; <span class="comment">// 声明局部变量 result，并使用局部变量a, b</span></span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 使用局部变量 result 作为返回值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>全局变量</strong></p>
<p>全局变量是指在合约的顶层预先定义的特殊变量，用于提供有关区块链和交易属性的信息。</p>
<p>全局变量是由 <code>Solidity</code> 语言本身提供，用户无权定义或者修改，但可以直接在任何位置使用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">GlobalVar</span> &#123;</span><br><span class="line">   <span class="comment">// 返回当前函数调用所在的区块号、时间戳、调用者地址</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">getGlobalVars</span>(<span class="params"></span>) public view <span class="title function_">returns</span>(<span class="params">uint,uint,address</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> (block.<span class="property">number</span>, block.<span class="property">timestamp</span>, msg.<span class="property">sender</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><code>Solidity</code> 为状态变量提供了 3 种可见性修饰符，分别是 <code>public</code>、<code>private</code> 和 <code>internal</code>，用于限制状态变量的访问权限。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 public delta = <span class="number">8</span>; <span class="comment">// 可见性声明为 public 合约内部和外部都可以访问这个状态变量</span></span><br><span class="line">uint256 private delta = <span class="number">8</span>; <span class="comment">// 可见性声明为 private 只能在合约内部访问这个状态变量</span></span><br></pre></td></tr></table></figure></div>

<p><strong>internal</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">InternalVisibility</span> &#123;</span><br><span class="line">  uint256 internal delta = <span class="number">8</span>; <span class="comment">// 可见性声明为 internal</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addDelta</span>(<span class="params">uint256 num</span>) external view <span class="title function_">returns</span>(<span class="params">uint256</span>) &#123;</span><br><span class="line">    uint256 sum = num + delta; <span class="comment">// 函数内可以使用状态变量 delta</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InheritedVisibility 继承合约 InternalVisibility</span></span><br><span class="line">contract <span class="title class_">InheritedVisibility</span> is <span class="title class_">InternalVisibility</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getDelta</span>(<span class="params"></span>) external view <span class="title function_">returns</span>(<span class="params">uint256</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> delta; <span class="comment">// 继承合约中可以使用状态变量 delta</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项：</strong>如果状态变量在声明的时候，没有指定可见性，那么它的可见性就为默认值 <code>internal</code>。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p><code>Solidity</code> 中有一个 <code>delete</code> 操作符，它可以对变量重新赋值，从字面意思来看，似乎是要删除一个变量，其实不是，<code>delete</code> 操作符只是对变量重新初始化，使其值变为默认值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">// 执行delete后，a = 0</span></span><br></pre></td></tr></table></figure></div>



<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在智能合约中，如果一个状态变量的值恒定不变，就可以使用关键字 <code>constant</code>  或者 <code>immutable</code> 进行修饰，把它定义为常量。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string constant <span class="variable constant_">SYMBOL</span> = <span class="string">&quot;WETH&quot;</span>;</span><br><span class="line">uint256 immutable <span class="variable constant_">TOTAL_SUPPLY</span> = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></div>

<p>状态变量一旦声明为 <code>constant</code>  和 <code>immutable</code> 后，就不能更改它的值了。</p>
<p> <code>constant</code>  和 <code>immutable</code>区别：</p>
<ul>
<li><p><code>constant</code>  关键字修饰的状态变量，必须在声明时就立即显式赋值，然后就不再允许修改了</p>
</li>
<li><p><code>immutable</code>  关键字修饰的状态变量，既可以在声明时显式赋值，还可以在合约部署时赋值，也就是在合约的<strong>构造函数</strong> <code>constructor</code> 中赋值</p>
</li>
<li><p><strong>适用的数据类型</strong></p>
<p><code>constant</code> 可以修饰任何数据类型。</p>
<p><code>immutable</code> 只能修饰值类型，比如：int、uint、bool、address 等，不能修饰 string、bytes 等引用类型。</p>
</li>
</ul>

  <div class="note p-4 mb-4 rounded-small default">
    <p><strong>注意事项：</strong></p>
<p>使用常量比变量更节省 <code>gas</code> 成本，这也是非常重要的一点。常量的值在编译时就已知，且不可改变，编译器会将其值直接嵌入到合约代码中，避免了在运行时进行存储和访问的开销。</p>

  </div>



<h2 id="solidity-函数"><a href="#solidity-函数" class="headerlink" title="solidity 函数"></a>solidity 函数</h2><p>在 <code>Solidity</code> 中，函数是合约中的可执行代码块，用于定义合约的行为和操作，函数和状态变量是 <code>Solidity</code> 智能合约中最重要的组成部分。</p>
<p><strong>函数定义如下：</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">function_name</span>(<span class="params">&lt;parameter list&gt;</span>) &lt;visibility&gt; &lt;state mutability&gt; [returns(&lt;return type&gt;)] &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>举例如下（一个加法函数）：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint a, uint b</span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数可见性共有 4 种，分别是 <code>private</code>、<code>public</code>、<code>internal</code>、<code>external</code>，用于限制函数的使用范围。</p>
<p>在 <code>Solidity</code> 的新版本中，<strong>函数定义中必须显式地指定可见性</strong>，不能省略，否则无法通过编译。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FunctionVisibility</span> &#123;</span><br><span class="line">    <span class="comment">// 可见性为 private，只能在合约内部调用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint a, uint b</span>) private pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可见性为 public，合约内部和外部均可调用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">uint a, uint b</span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可见性为 internal，合约内部和继承合约中可以调用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mul</span>(<span class="params">uint a, uint b</span>) internal pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可见性为 external，只能在合约外部调用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">div</span>(<span class="params">uint a, uint b</span>) external pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如图可以看到只有 div 和 sub 可以从外部调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-00-27.png"
                      alt="nipaste_2024-07-29_20-00-2"
                ></p>
<p><strong>返回值</strong></p>
<p>在 <code>Solidity</code> 中，<strong>函数可以没有返回值，也可以返回一个或多个值</strong>，返回值可以是任何有效的数据类型，在函数声明中，需要使用 <code>returns</code> 关键字指定返回值的类型。</p>
<p>在函数体中，可以有两种方式来返回结果值：</p>
<ol>
<li>使用 <code>return</code> 关键字指定返回值；</li>
<li>使用返回值的参数名称指定返回值。</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FunctionReturn</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 `return` 关键字指定返回值</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">uint a, uint b</span>) public pure returns (uint)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用返回值的参数名称指定返回值</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params">uint a, uint b</span>) public pure returns (uint result)&#123;</span><br><span class="line">    result = a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>多返回值</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FunctionMultiReturn</span> &#123;</span><br><span class="line">  <span class="comment">// 多返回值</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addAndMul</span>(<span class="params">uint a, uint b</span>) public pure returns (uint, uint)&#123;</span><br><span class="line">    uint sum = a + b;</span><br><span class="line">    uint product = a * b;</span><br><span class="line">    <span class="keyword">return</span> (sum, product);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>solidity 支持函数重载</strong></p>
<h3 id="状态可变性-visibility"><a href="#状态可变性-visibility" class="headerlink" title="状态可变性 visibility"></a>状态可变性 visibility</h3><p>函数的状态可变性有 4 种：<code>pure</code>、<code>view</code>、<code>payable</code>、未标记状态。	</p>
<p><strong>1. pure</strong></p>
<p>状态可变性为 <code>pure</code> 的函数，也称为纯函数，是指<strong>函数不会读取和修改合约的状态</strong>，换言之，<code>pure</code> 函数不会读取和修改链上的数据，例如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MutabilityPure</span> &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      uint a = <span class="number">2</span>;  <span class="comment">// 局部变量 a</span></span><br><span class="line">      uint b = <span class="number">3</span>;  <span class="comment">// 局部变量 b</span></span><br><span class="line">      <span class="keyword">return</span> a + b; <span class="comment">// 只使用了局部变量 a、b</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于上面的代码只使用了局部变量，并不涉及到全局变量和状态变量，因此可以将可变性设置为 pure。</p>
<p>在下面的情况下就不能使用 pure，不然不能通过编译</p>
<ul>
<li>读取状态变量</li>
<li>访问 <code>&lt;address&gt;.balance</code></li>
<li>访问任何区块、交易、msg等全局变量</li>
<li>调用了任何不是纯函数的函数</li>
<li>使用包含特定操作码的内联汇编</li>
</ul>
<p><strong>2. view</strong></p>
<p>状态可变性为 <code>view</code> 的函数，也称为视图函数，是指函数会读取合约的状态，但不会进行修改。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MutabilityView</span> &#123;</span><br><span class="line">    uint factor = <span class="number">2</span>;  <span class="comment">// 状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">times</span>(<span class="params">uint num</span>) public view <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> num * factor;  <span class="comment">// 使用了状态变量 factor</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码只是对状态变量进行了读取，但并没有修改其值，因此可以将可变性设置为 view。</p>
<p>对于下列情况就不适用于 view：</p>
<ul>
<li>修改状态变量</li>
<li>触发事件</li>
<li>创建其它合约</li>
<li>使用了自毁函数 <code>selfdestruct</code></li>
<li>调用发送以太币</li>
<li>调用任何不是 <code>view</code> 或 <code>pure</code> 的函数</li>
<li>使用了底层调用</li>
<li>使用包含特定操作码的内联汇编</li>
</ul>
<p><strong>3. 未标记状态可变性</strong></p>
<p>如果一个函数定义中没有标记任何状态可变性，也就是说，函数既没标记为 <code>view</code>  也没标记为 <code>pure</code> ，那么就意味着这个函数是要改变状态的</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MutabilityNone</span> &#123;</span><br><span class="line">    uint factor = <span class="number">2</span>;  <span class="comment">// 状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setFactor</span>(<span class="params">uint _factor</span>) public &#123;</span><br><span class="line">      factor = _factor;  <span class="comment">// 重设了状态变量 factor 的值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>4. payable 状态可变性</strong></p>
<p>如果一个函数的状态可变性标记为 <code>payable</code>，那么就表示它可以接收以太币，这些以太币是由调用者在调用函数时支付的。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MutabilityPayable</span> &#123;</span><br><span class="line">   <span class="comment">// 投注函数标记为 payable，表示它可以接收以太币</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">stake</span>(<span class="params">uint teamID</span>) public payable &#123; </span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>设置状态可变性的作用：</p>
<ul>
<li>安全性</li>
<li>可靠性： <code>view</code>、<code>pure</code> 修饰的函数在调用时不会产生副作用，因此可以安全地被其它函数调用</li>
<li>互操作性：通过标记函数的状态可变性，可以提供给其它合约和工具有关函数的重要信息</li>
</ul>
<blockquote>
<p>调用 view 、pure 函数，无需支付 gas，而调用非 view 、pure 函数就需要支付一定的 gas</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FuncConstructor</span> &#123;</span><br><span class="line">  uint256 totalSupply; <span class="comment">// 状态变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">uint256 _totalSupply</span>) payable &#123;</span><br><span class="line">    totalSupply = _totalSupply;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于构造函数不需要设置为 pure 或者 view，因为构造函数常用来初始化合约，会改变合约的状态，如果在部署一个合约的时候，同时需要向合约内存入一些以太币，那么就需要将构造函数的可见性设置为 <code>payable</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FuncConstructor</span> &#123;</span><br><span class="line">  uint256 totalSupply; <span class="comment">// 状态变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">uint256 _totalSupply</span>) payable &#123;</span><br><span class="line">    totalSupply = _totalSupply;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>经典示例</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FuncConstructor</span> &#123;</span><br><span class="line">  address _owner; <span class="comment">// 合约部署者</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    _owner = msg.<span class="property">sender</span>; <span class="comment">// 将合约部署者保存到状态变量 _owner</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只允许合约部署者操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">operate</span>(<span class="params"></span>) public view &#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.<span class="property">sender</span> == _owner, <span class="string">&quot;caller is not the owner&quot;</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取合约部署者</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">owner</span>(<span class="params"></span>) public view returns (address) &#123;</span><br><span class="line">    <span class="keyword">return</span> _owner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段合约代码在部署的时候，将调用构造函数 <code>constructor</code>，把合约部署者的地址 msg.sender 记录在了状态变量 _owner 中， _owner 类似于合约的管理员，比普通用户拥有更大的权限。</p>
<p>比如，下面的函数 operate，<strong>就只能由合约部署者使用</strong>，而其它用户不能使用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(msg.sender == _owner, &quot;caller is not the owner&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里判断调用者是不是合约部署者 _owner。 如果是合约部署者的话，就继续向后执行；如果不是的话，就会输出错误信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-24-28.png"
                      alt="nipaste_2024-07-29_20-24-2"
                ></p>
<p>点击函数 owner，可以获取合约部署者地址，</p>
<h3 id="接受函数-receive"><a href="#接受函数-receive" class="headerlink" title="接受函数 receive"></a>接受函数 receive</h3><p>在以太坊区块链中存在两种类型的账户：<code>外部账户</code> 和 <code>合约账户</code>，它们在以太坊上有着不同的特性和用途。</p>
<p><strong>1. 外部账户</strong></p>
<p>外部账户，英文为 Externally Owned Account，缩写为 <code>EOA</code>，外部账户也就是平常使用的用户账户，用于存储以太币 <code>ETH</code> 。这些账户可以向其它账户发送以太币，或者从其它账户接收以太币。</p>
<p>在钱包里管理的账户，通常就是外部账户。比如，在小狐狸钱包 <code>Metamask</code> 里添加或者生成的 <code>Account</code> 就是外部账户。<strong>外部账户会有一个与之相关的以太坊地址</strong>，这个地址是一个以 “0x” 开头，长度为20字节的十六进制数，比如：0x7CA35…9C6F。<strong>外部账户都有一个对应的私钥</strong>，只有持有私钥的人才能对交易进行签名，所以，外部账户非常适用于资金管理。</p>
<p><strong>常说的以太坊账户，在不特别指明的情况下，一般是指外部账户</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-29-30.png"
                      alt="nipaste_2024-07-29_20-29-3"
                ></p>
<p>上图就是外部账户，同时拥有一个对应的私钥。</p>
<p><strong>2. 合约账户</strong></p>
<p>合约账户，英文为 <code>Contract Account</code>，缩写为 <code>CA</code>。在以<strong>太坊区块链上部署一个智能合约后</strong>，都会产生一个对应的<strong>合约地址</strong>，<strong>这个地址称为合约账户</strong>。合约账户主要用于托管智能合约，它里面包含着智能合约的二进制代码和状态信息。<strong>合约账户地址的格式与外部账相同</strong>：以 “0x” 开头，长度为20字节的十六进制数。<strong>合约账户没有私钥</strong>，只能由智能合约中的代码逻辑进行控制。</p>
<p>它在一定条件下，也可以用来存储以太币 <code>ETH</code>。</p>
<p><strong>3. receive 函数</strong></p>
<p>在以太坊区块链上<strong>部署智能合约时产生的合约账户</strong>，并不都是可以存入以太币<code>ETH</code> 的。<strong>一个智能合约如果允许存入以太币，就必须实现 <code>receive</code> 或者 <code>fallback</code> 函数</strong>。如果一个智能合约中这两个函数都没有定义，那么它就不能接收以太币。</p>
<p>如果只是为了让合约账户能够存入以太币，按照 <code>solidity</code> 语言规范，推荐使用 <code>receive</code> 函数。因为 <code>receive</code> 函数简单明了，目的明确，而 <code>fallback</code>  函数的用途相对复杂一些。</p>
<p>格式如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">receive</span>() external payable &#123;</span><br><span class="line">    <span class="comment">// 这里可以添加自定义的处理逻辑，但也可以为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>receive</code> 函数有如下几个特点：</p>
<ul>
<li>无需使用 <code>function</code> 声明。</li>
<li>参数为空。</li>
<li>可见性必须设置为 <code>external</code>。</li>
<li>状态可变性必须设置为 <code>payable</code>。</li>
</ul>
<p>当<strong>外部地址向智能合约地址发送以太币时</strong>，将触发执行 <code>receive</code> 函数，<strong>可以在函数体内不写任何自定义的处理逻辑，它依然能够接收以太币，这也是最常见的使用方式</strong>。</p>
<p>如果必须在 <code>receive</code> 的函数体内添加处理语句的话，<strong>最好不要添加太多的业务逻辑</strong>。</p>
<p>因为外部调用 <code>send</code> 和 <code>transfer</code> 方法进行转账的时候，为了防止重入攻击，<code>gas</code> 会限制在 2300。如果 <code>receive</code> 的函数太复杂，就很容易会耗尽 <code>gas</code>，从而触发交易回滚。</p>
<p><code>receive</code> 函数里通常会执行一些简单记录日志的动作，比如触发 <code>event</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FuncReceive</span> &#123;</span><br><span class="line">  <span class="comment">// 定义接收事件</span></span><br><span class="line">  event <span class="title class_">Received</span>(address sender, uint amount);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 接收 ETH 时，触发 Received 事件</span></span><br><span class="line">  <span class="title function_">receive</span>() external payable &#123;</span><br><span class="line">    emit <span class="title class_">Received</span>(msg.<span class="property">sender</span>, msg.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-37-02.png"
                      alt="nipaste_2024-07-29_20-37-0"
                ></p>
<h3 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 fallback"></a>回退函数 fallback</h3><p>在 <code>Solidity</code> 语言中，<code>fallback</code> 是一个预定义的特殊函数，用于在<strong>处理未知函数</strong>和<strong>接收以太币 ETH</strong> 时调用。</p>
<p>定义 <code>fallback</code> 函数的格式如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fallback () external [payable] &#123;</span><br><span class="line">  <span class="comment">// 这里可以添加自定义的处理逻辑，但也可以为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>fallback</code> 函数有如下几个特点：</p>
<ul>
<li>无需使用 <code>function</code>声明。</li>
<li>参数为空。</li>
<li>可见性必须设置为 <code>external</code>。</li>
<li>状态可变性可以为空，或者设置为 <code>payable</code>。</li>
</ul>
<p><strong>调用条件</strong></p>
<p><code>fallback</code> 会在两种情况下，被外部事件触发而执行：</p>
<ul>
<li><p>外部调用了智能合约中不存在的函数</p>
<p>在这种情况下，函数声明中无需设置状态可变性，函数形式如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fallback () external &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>外部向智能合约中存入以太币，并且当前合约中不存在 receive 函数</p>
<p>在这种情况下，函数声明中必须设置状态可变性为 <code>payable</code>，函数形式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fallback () external payable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>如果合约中已经定义了 <code>receive</code>函数，那么向这个合约中存入以太币，将会优先调用 <code>receive</code> 函数，而不会执行 <code>fallback</code> 函数。</p>
<blockquote>
<p>所以，如果一个智能合约允许存入以太币，那么它就必须实现 <code>receive</code> 或者 <code>fallback</code> 函数，而且函数的状态可变性设置为 <code>payable</code>。如果一个智能合约没有定义这两个函数中的任何一个，那么它就不能接收以太币</p>
</blockquote>
<h3 id="receive-和-fallback-工作流程"><a href="#receive-和-fallback-工作流程" class="headerlink" title="receive 和 fallback 工作流程"></a>receive 和 fallback 工作流程</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-43-08.png"
                      alt="nipaste_2024-07-29_20-43-0"
                ></p>
<p>当参数 <code>msg.data</code> 为空时，就意味着：外部向合约进行转账，存入以太币。</p>
<p>当参数 <code>msg.data</code> 不为空时，就意味着：外部在调用合约中的函数。</p>
<p>在左边的分支可以看到，<code>receive</code> 和 <code>fallback</code> 函数都能够用于接收以太币 <code>ETH</code>。</p>
<p>一个智能合约在接收 <code>ETH</code> 时:</p>
<ul>
<li>如果存在着 <code>receive</code> 函数，就会触发 <code>receive</code>；</li>
<li>当不存在 <code>receive</code> 函数，但存在 <code>fallback</code> 函数时，就会触发 <code>fallback</code>；</li>
<li>而当两者都不存在时，交易就会 <code>revert</code>，存入 <code>ETH</code> 失败</li>
</ul>
<p><strong>测试和验证</strong></p>
<p><strong>第一种情况</strong></p>
<p>智能合约中只定义 <code>fallback</code> 函数，而且状态可变性为 <code>payable</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FuncFallback</span> &#123;</span><br><span class="line">  <span class="comment">// 定义回退事件</span></span><br><span class="line">  event <span class="title class_">Fallback</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fallback</span>() external payable &#123;</span><br><span class="line">    emit <span class="title class_">Fallback</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-47-22.png"
                      alt="nipaste_2024-07-29_20-47-2"
                ></p>
<p>转了 100wei，由于没有receive函数，所以触发fallback函数。</p>
<p><strong>第二种情况</strong></p>
<p>智能合约中同时定义了 <code>receive</code> 和 <code>fallback</code> 函数，而且两者的状态可变性都为 <code>payable</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FuncFallback</span> &#123;</span><br><span class="line">  <span class="comment">// 定义接收事件</span></span><br><span class="line">  event <span class="title class_">Receive</span>();</span><br><span class="line">  <span class="comment">// 定义回退事件</span></span><br><span class="line">  event <span class="title class_">Fallback</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">receive</span>() external payable &#123;</span><br><span class="line">    emit <span class="title class_">Receive</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fallback</span>() external payable &#123;</span><br><span class="line">    emit <span class="title class_">Fallback</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-49-21.png"
                      alt="nipaste_2024-07-29_20-49-2"
                ></p>
<p>果不其然，两者同时存在的情况下，会优先调用 receive 函数。</p>
<p><strong>第三种情况</strong></p>
<p>依然使用上面的合约，当调用一个不存在的函数，将会触发 <code>Fallback</code> 事件。</p>
<p>这里依然使用第二种情况中的例子，在 <strong>“CALLDATA”</strong> 栏中填入随意编写的 <code>msg.data</code> 数据，使之不为空，再点击 **”Transact”**，可以看到交易成功，并且触发了 <code>Fallback</code> 事件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_20-52-45.png"
                      alt="nipaste_2024-07-29_20-52-4"
                ></p>
<p>可以看到在 msg.data 不为空的情况下，这里触发了 fallback 函数。</p>
<h2 id="solidity-流程控制语句"><a href="#solidity-流程控制语句" class="headerlink" title="solidity 流程控制语句"></a>solidity 流程控制语句</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>与 C 语言大体一致</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>与 C 语言大体一致</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>与 C 语言大体一致</p>
<h3 id="断言语句"><a href="#断言语句" class="headerlink" title="断言语句"></a>断言语句</h3><p><code>Solidity</code> 提供了断言语句，用于在合约执行过程中进行条件检查和错误处理，<code>Solidity</code> 支持两种断言语句：<code>require</code> 和 <code>assert</code>。</p>
<p><strong>1. require</strong></p>
<p><code>require</code> 语句用于检查函数执行的先决条件，也就是说，确保满足某些特定条件后才能继续执行函数，如果条件不满足，则会中止当前函数的执行，并回滚(<code>revert</code>)所有的状态改变</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Require</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转账函数  </span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address to, uint256 amount</span>) public pure &#123;</span><br><span class="line">    <span class="built_in">require</span>(to != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;address `to` is zero&quot;</span>);</span><br><span class="line">    <span class="built_in">require</span>(amount &gt; <span class="number">0</span>, <span class="string">&quot;`amount` is zero&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行转账操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用 transfer 函数，然后将 to 设置为 0 然后调用，可以发现报错。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_21-02-25.png"
                      alt="nipaste_2024-07-29_21-02-2"
                ></p>
<p>同时将 amount 设置为 0，也会触发报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-29_21-04-55.png"
                      alt="nipaste_2024-07-29_21-04-5"
                ></p>
<p><code>require</code> 完全可以使用 <code>revert</code> 语句来代替。比如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(amount &gt; 0, &quot;`amount` is zero&quot;);</span><br></pre></td></tr></table></figure></div>

<p>就可以使用 <code>revert</code> 语句改写为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(amount &lt;= 0) &#123; </span><br><span class="line">  revert(&quot;`amount` is zero&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上两种写法完全等价。关于 <code>revert</code> 实现原理，将在后面的章节中详细讲解。</p>
<p><strong>2. assert</strong></p>
<p><code>assert</code> 语句的行为 <code>require</code> 非常类似，通常用于捕捉合约内部编程错误和异常情况。</p>
<p>如果捕捉到了异常，则会中止当前函数的执行，并回滚(<code>revert</code>)所有的状态改变。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Assert</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 除法函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">uint256 dividend, uint256 divisor</span>) public pure <span class="title function_">returns</span>(<span class="params">uint256</span>) &#123;</span><br><span class="line">    <span class="title function_">assert</span>(divisor != <span class="number">0</span>); <span class="comment">// 确保除数不为零</span></span><br><span class="line">    <span class="keyword">return</span> dividend / divisor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>合约中有一个除法函数 divide，在调用的时候，需要首先检测除数 divisor 是否为 0，如果为 0 ，触发异常，函数终止运行。只有除数 divisor 不为 0 ，才会执行除法操作。</p>
<p><code>require</code> 和 <code>assert</code> 都能终止函数的执行，并回滚交易，但两者有一些区别。</p>
<ol>
<li><code>require</code> 和 <code>assert</code>  参数不同，<code>require</code> <strong>可以带有一个说明原因的参数</strong>，<code>assert</code> 没有这个参数。</li>
<li><code>require</code> 通常用于<strong>检查外部输入是否满足要求</strong>，而 <code>assert</code> 用于<strong>捕捉内部编程错误和异常情况</strong>。</li>
<li><code>require</code> 通常<strong>位于函数首部</strong>来检查参数，<code>assert</code> 则通常<strong>位于函数内部</strong>，当出现严重错误时触发。</li>
<li><code>assert</code> 是 <code>Solidity</code> 早期版本遗留下来的函数，<strong>不再建议使用</strong>，最好使用 <code>require</code> 和 <code>revert</code> 代替。</li>
</ol>
<p><code>require</code> 在实际运行的合约中使用广泛，通常用来检查输入参数的正确性，我们要熟练掌握它的使用方法。</p>
<h2 id="solidity-复合数据类型"><a href="#solidity-复合数据类型" class="headerlink" title="solidity 复合数据类型"></a>solidity 复合数据类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>Solidity</code> 支持 <code>固定长度数组</code> 和 <code>动态长度数组</code> 两种类型</p>
<p><strong>固定长度数组</strong></p>
<p>格式如下</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type_name arrayName [length];</span></span><br><span class="line"><span class="comment">//举例：</span></span><br><span class="line">uint balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>初始化一个 <code>固定长度数组</code>，可以使用下面的语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint balance[3] = [uint(1), 2, 3]; // 初始化固定长度数组</span><br><span class="line">balance[2] = 5; // 设置第 3 个元素的值为 5</span><br></pre></td></tr></table></figure></div>

<p><strong>动态长度数组</strong></p>
<p><code>动态长度数组</code> 与 <code>固定长度数组</code> 相比，就是 <code>动态长度数组</code> 的长度是可以改变的。</p>
<p>声明一个 <code>动态长度数组</code>，只需要指定元素类型，而不需要指定元素的数量，语法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_name arrayName[];</span><br><span class="line">uint[] balance = [uint(1), 2, 3];</span><br></pre></td></tr></table></figure></div>

<p>对于动态长度数组，可以使用 push 和 pop 方法</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化动态长度数组为[1,2,3]</span></span><br><span class="line">    uint[] balance = [<span class="title function_">uint</span>(<span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dynamicArray</span>(<span class="params"></span>) external returns (uint length, uint[] memory array) &#123;</span><br><span class="line">        <span class="comment">// 追加两个新元素4、5</span></span><br><span class="line">        balance.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">        balance.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最后一个元素 5</span></span><br><span class="line">        balance.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回数组的长度和数组所有元素</span></span><br><span class="line">        <span class="keyword">return</span> (balance.<span class="property">length</span>, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>new、delete 操作</strong></p>
<p>可以使用 <code>new</code> 关键字来动态创建一个数组。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Array</span> &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">newArray</span>(<span class="params"></span>) external pure <span class="title function_">returns</span>(<span class="params">uint[] memory</span>) &#123;</span><br><span class="line">      uint[] memory arr = <span class="keyword">new</span> uint[](<span class="number">3</span>);</span><br><span class="line">      arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> arr;  <span class="comment">// 返回结果 arr = [1,0,0]</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过 <code>new</code> 关键字创建的数组是一个动态长度数组。它是无法一次性赋予初值的，只能对每一个元素的值分别进行设置。</p>
<p>在前面已经讲过，**<code>delete</code> 操作符只是对变量值重新初始化，使其值变为默认值，而不是删除这个变量**。在数组上使用 <code>delete</code> 操作，效果也是一样的。</p>
<p>delete arr[i]，并不是要删除一个数组中的元素，而是将该元素恢为默认值，例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint[] balance = [uint(1), 2, 3];</span><br><span class="line">delete balance[0]; // 执行 delete 后，balance = [0,2,3]</span><br></pre></td></tr></table></figure></div>

<p><strong>除了动态长度数组的 <code>pop</code> 函数外，<code>Solidity</code> 并没有提供删除某个特定元素的函数</strong>。</p>
<h3 id="字节和字符串"><a href="#字节和字符串" class="headerlink" title="字节和字符串"></a>字节和字符串</h3><p><code>字节型</code> 也是 <code>Solidity</code> 语言中重要的数据类型，<code>字节型</code> 用于表示特定长度的字节序列，分为 <code>固定长度字节型</code> 和 <code>动态长度字节型</code> 两种类型，<code>字节型</code> 本质上是一个字节数组。</p>
<p>比如，在<strong>智能合约中经常出现的哈希值、数据签名等数据</strong>，都会使用 <code>字节型</code> 来定义。</p>
<p><strong>固定长度字节型</strong></p>
<p><code>固定长度字节型</code> 按照长度分为 32 种小类，使用 <code>bytes1</code>、<code>bytes2</code>、<code>bytes3</code> 直到 <code>bytes32</code> 表示，每种类型代表不同长度的字节序列，其中的 <code>bytes32</code> 使用最为普遍。</p>
<p><code>固定长度字节型</code> 的变量声明如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes1 myBytes1 = <span class="number">0x12</span>;  <span class="comment">// 单个字节</span></span><br><span class="line">bytes2 myBytes2 = <span class="number">0x1234</span>;  <span class="comment">// 两个字节</span></span><br><span class="line">bytes32 myBytes32 = <span class="number">0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef</span>; <span class="comment">// 32个字节</span></span><br></pre></td></tr></table></figure></div>

<p><strong>动态长度字节型</strong></p>
<p><code>动态长度字节型</code> 可以存储任意长度的字节序列，它使用关键字 <code>bytes</code> 来声明，在声明变量时，需要指定其长度或初始化值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes myBytes = <span class="keyword">new</span> <span class="title function_">bytes</span>(<span class="number">10</span>);  <span class="comment">// 声明一个长度为 10 的动态长度字节变量</span></span><br><span class="line">bytes myBytes = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 声明一个动态长度字节变量，并初始化为 &quot;Hello&quot;</span></span><br><span class="line">bytes myBytes = hex<span class="string">&quot;1234&quot;</span>;  <span class="comment">// 声明一个动态长度字节变量，并初始化为十六进制 0x1234</span></span><br></pre></td></tr></table></figure></div>

<p>示例：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">DynamicBytes</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dynamicBytes</span>(<span class="params"></span>) external pure returns (uint256, bytes memory) &#123;</span><br><span class="line">        bytes memory myBytes = <span class="keyword">new</span> <span class="title function_">bytes</span>(<span class="number">2</span>); <span class="comment">// 创建动态长度字节型变量</span></span><br><span class="line">        myBytes[<span class="number">0</span>] = <span class="number">0x12</span>; <span class="comment">// 设置单个字节的值</span></span><br><span class="line">        myBytes[<span class="number">1</span>] = <span class="number">0x34</span>; </span><br><span class="line">        <span class="keyword">return</span> (myBytes.<span class="property">length</span>, myBytes);<span class="comment">// .length 取字符串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>字符串</strong></p>
<p>在 <code>Solidity</code> 中，<code>字符串</code> 是用来存储文本数据的类型。<code>字符串</code>的值使用双引号 (“) 或单引号 (‘) 包裹，类型用 <code>string</code> 表示。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string public myString = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure></div>

<p><code>字符串</code>与固定长度的字节数组非常类似，它的值在声明之后就不可变了，如果想要对<code>字符串</code>中包含的字符进行操作，通常会将它转换为 <code>bytes</code> 类型。</p>
<p><code>Solidity</code> 提供了字节数组 <code>bytes</code> 与字符串 <code>string</code> 之间的内置转换。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bytes 转换 string</span></span><br><span class="line"><span class="title function_">string</span>(myBytes);</span><br><span class="line"><span class="comment">//string 转换 bytes</span></span><br><span class="line"><span class="title function_">bytes</span>(myString);</span><br><span class="line"><span class="comment">//获得字符串长度</span></span><br><span class="line"><span class="title function_">bytes</span>(myString).<span class="property">length</span>; </span><br></pre></td></tr></table></figure></div>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>定义一个结构体类型使用 <code>struct</code> 关键字，它的语法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct struct_name &#123; </span><br><span class="line">   type1 type_name_1;</span><br><span class="line">   type2 type_name_2;</span><br><span class="line">   type3 type_name_3;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>struct_name</code> 是结构体的名称，<code>typeN</code> 是结构体成员的数据类型，<code>type_name_N</code> 是结构体成员的名字。</p>
<p>这里定义一个结构体类型 <code>Book</code>，用来表示一本书：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Book &#123; </span><br><span class="line">   string title;</span><br><span class="line">   string author;</span><br><span class="line">   uint ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用方法</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">StructAccess</span> &#123;</span><br><span class="line">   struct <span class="title class_">Book</span> &#123; </span><br><span class="line">     string title;</span><br><span class="line">     string author;</span><br><span class="line">     uint <span class="variable constant_">ID</span>;</span><br><span class="line">   &#125;  <span class="comment">// 定义结构体 Book</span></span><br><span class="line"></span><br><span class="line">   <span class="title class_">Book</span> book;  <span class="comment">// 使用结构体 Book 声明变量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">setBook</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      book.<span class="property">title</span> = <span class="string">&quot;Learn Solidity&quot;</span>; <span class="comment">// 设置结构体的成员 title</span></span><br><span class="line">      book.<span class="property">author</span> = <span class="string">&quot;BinSchool&quot;</span>;</span><br><span class="line">      book.<span class="property">ID</span> = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getBookAuthor</span>(<span class="params"></span>) public view <span class="title function_">returns</span>(<span class="params">string memory</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> book.<span class="property">author</span>; <span class="comment">// 读取结构体的成员 author</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>初始化方式</strong></p>
<p>结构体变量共有 3 种初始化数据的方式：<strong>按字段顺序初始化</strong>、<strong>按字段名称初始化</strong>、<strong>按默认值初始化</strong>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">StructInit</span> &#123;</span><br><span class="line">  struct <span class="title class_">Book</span> &#123; </span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    uint <span class="variable constant_">ID</span>;</span><br><span class="line">  &#125;  <span class="comment">// 定义结构体 Book</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getBooks</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">Book memory,Book memory,Book memory</span>) &#123;</span><br><span class="line">    <span class="comment">// 按字段顺序初始化</span></span><br><span class="line">    <span class="title class_">Book</span> memory book1 = <span class="title class_">Book</span>(<span class="string">&#x27;Learn Java&#x27;</span>, <span class="string">&#x27;BinSchool&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按字段名称初始化</span></span><br><span class="line">    <span class="title class_">Book</span> memory book2 = <span class="title class_">Book</span>(&#123;<span class="attr">title</span>:<span class="string">&quot;Learn JS&quot;</span>, <span class="attr">author</span>:<span class="string">&quot;BinSchool&quot;</span>, <span class="attr">ID</span>:<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按默认值初始化</span></span><br><span class="line">    <span class="title class_">Book</span> memory book3;</span><br><span class="line">    book3.<span class="property">ID</span> = <span class="number">3</span>;</span><br><span class="line">    book3.<span class="property">title</span> = <span class="string">&#x27;Learn Solidity&#x27;</span>;</span><br><span class="line">    book3.<span class="property">author</span> = <span class="string">&#x27;BinSchool&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> (book1, book2, book3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p><code>Solidity</code> 中的映射类型 <code>mapping</code>，用来以<strong>键值对</strong>的形式存储数据。它的主要作用是提供高效的查找功能，类似于其它编程语言中的哈希表或者字典。</p>
<p>例如，在使用 <code>白名单</code> 的场景中，可以通过 <code>映射类型</code> 将用户地址映射到一个布尔值，以标识哪些地址是被允许的，哪些地址是不被允许的，从而高效地控制访问权限。</p>
<p><strong>映射类型是智能合约中最常用的数据类型之一</strong></p>
<p>语法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(key_type =&gt; value_type)</span><br></pre></td></tr></table></figure></div>

<p><code>mapping</code> 类型是将一个键 (<strong>key</strong>) 映射到一个值 (<strong>value</strong>)。 </p>
<p>其中：<strong>key_type</strong> 可以是<strong>任何基本数据类型</strong>，比如：整型、地址型、布尔型、枚举型，以及 <code>bytes</code> 和 <code>string</code>，但是<strong>部分复杂对象不允许使用</strong>，比如：动态数组、结构体、映射。</p>
<p>**value_type 可以是任何数据类型 **</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="title class_">MyStruct</span> &#123; uint256 value; &#125; <span class="comment">// 定义一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) a; <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">mapping</span>(<span class="function"><span class="params">string</span> =&gt;</span> bool[]) b; <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">mapping</span>(<span class="function"><span class="params">int</span> =&gt;</span> <span class="title class_">MyStruct</span>) c; <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint)) d; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mapping(uint[] =&gt; uint) public e;  // 错误</span></span><br><span class="line"><span class="comment">// mapping(MyStruct =&gt; addrss) public f; // 错误</span></span><br><span class="line"><span class="comment">// mapping(mapping(string=&gt;int)) =&gt; uint) g; // 错误</span></span><br></pre></td></tr></table></figure></div>

<p>在智能合约中，<code>mapping</code> 类型的使用非常普遍的。比如，在 <code>ERC20</code> 代币合约中，经常会使用 <code>mapping</code> 类型的变量作为一个内部账本，用来记录每一个钱包地址拥有的代币余额。</p>
<p>下面例子模拟了一个稳定币 <code>USDT</code> 的合约：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="variable constant_">USDT</span> &#123;</span><br><span class="line">  <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) balances; <span class="comment">// 保存所有持有 USDT 账户的余额</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数，合约部署时自动调用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    balances[msg.<span class="property">sender</span>] = <span class="number">100</span>; <span class="comment">// 初始设定合约部署者的账户余额为 100 USDT</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询某一个账户的USDT余额</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">balanceOf</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span>(<span class="params">uint256</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> balances[account];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>复制上面的合约地址，然后传给下面的 balanceof 函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-30_10-43-18.png"
                      alt="nipaste_2024-07-30_10-43-1"
                ></p>
<p>返回值为 100</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-30_10-44-15.png"
                      alt="nipaste_2024-07-30_10-44-1"
                ></p>
<p><strong>注意：</strong>在 <code>mapping</code> 类型的变量中获取一个不存在的键的值，并不会报错，而是会返回<strong>值类型</strong>的默认值。比如，整型会返回 0，布尔型会返回 false 等。</p>
<p><strong>优缺点</strong></p>
<p><strong>优点：</strong></p>
<p><code>mapping</code> 可以用来存储数据集，并且提供了高效的查找功能。它可以根据“键”快速定位到特定元素。</p>
<p><strong>缺点：</strong></p>
<p><code>mapping</code> 最大的问题是无法直接遍历。</p>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>当调用一个函数时，如果参数为<strong>值类型</strong>，那么在函数内部对参数数据进行修改，是不会影响到原始数据的</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ValueOps</span> &#123;</span><br><span class="line">  <span class="comment">// 更新值类型的值</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) external pure <span class="title function_">returns</span>(<span class="params">bytes2</span>)&#123;</span><br><span class="line">     <span class="comment">// 原始数据 data 的值为 0x1234</span></span><br><span class="line">     bytes2 data = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">// 调用函数修改它的值</span></span><br><span class="line">    <span class="title function_">updateValue</span>(data);</span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">//返回值依然是 0x1234</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 修改第一个字符为 0x4567</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateValue</span>(<span class="params">bytes2 value</span>) internal pure &#123;</span><br><span class="line">    value = <span class="number">0x4567</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>引用类型</strong></p>
<p>在 <code>Solidity</code> 中引用类型共有三种：数组、结构体 <code>struct</code> 和映射 <code>mapping</code>。（类似于C中的指针）</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ReferenceOps</span> &#123;</span><br><span class="line">  <span class="comment">// 更新引用类型的值</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) external pure <span class="title function_">returns</span>(<span class="params">string memory</span>)&#123;</span><br><span class="line">    <span class="comment">// 原始数据 data 的值为 &quot;1234&quot;</span></span><br><span class="line">    bytes memory data = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用函数修改它的第一个字符为 &#x27;5&#x27;</span></span><br><span class="line">    <span class="title function_">updateValue</span>(data);</span><br><span class="line">    <span class="comment">// 将其转为字符串，输出最终结果 0x5234</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">string</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改第一个字符为 &#x27;5&#x27;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateValue</span>(<span class="params">bytes memory value</span>) internal pure &#123;</span><br><span class="line">    value[<span class="number">0</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h3><p><code>Solidity</code> 中的数据的存储位置有 3 种：<code>memory</code>、<code>storage</code>、<code>calldata</code>。</p>
<p><strong>1. storage</strong></p>
<p><code>storage</code> 是指<strong>永久保存在区块链上的存储</strong>，通常用于存储合约的状态变量。</p>
<p><code>storage</code> 中的变量在合约部署后会一直存在，直到合约被销毁。</p>
<p>由于它保存在区块链上，需要<strong>同步到所有区块链节点</strong>，而且永久保存，<strong>所以它的使用成本高，<code>gas</code> 消耗多</strong>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract StorageVar &#123;</span><br><span class="line">  string name = &quot;BinSchool.app&quot;;  // 声明状态变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>name</code> 是一个状态变量，存储在 <code>storage</code> 中，它的数据会一直保存在区块链上。</p>
<p>在函数中，对于“引用类型”的状态变量，可以通过关键字 <code>storage</code> 来引用它。例如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">StorageVar</span> &#123;</span><br><span class="line">  <span class="comment">// 引用类型的状态变量</span></span><br><span class="line">  uint[] data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改状态变量</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) external &#123;</span><br><span class="line">    <span class="comment">// 变量 dataRef 引用了状态变量 data</span></span><br><span class="line">    uint[] storage dataRef = data;</span><br><span class="line">    <span class="comment">// 修改 dataRef </span></span><br><span class="line">    dataRef[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 打印状态变量</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) external view <span class="title function_">returns</span>(<span class="params">uint, uint, uint</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (data[<span class="number">0</span>],data[<span class="number">1</span>],data[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为状态变量 <code>data</code> 创建了一个引用 <code>dataRef</code>，然后修改了 <code>dataRef</code> 的值,<code>dataRef</code> 和 <code>data</code> 实际上指向了同一块数据，也可以说，<code>dataRef</code> 是 <code>data</code> 的别名，所以，修改了 <code>dataRef</code> 指向的数据，也就是修改了 <code>data</code> 指向的数据。</p>
<p><strong>2. memory</strong></p>
<p><code>memory</code> 是函数调用期间分配的临时内存，通常用于存储引用类型的局部变量。<code>memory</code> 中的变量在函数调用结束后会被销毁。它对应于其它编程语言中的 “堆”。</p>
<p><code>memory</code> 的使用成本非常低，消耗的 <code>gas</code> 少。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">MemoryVar</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">string memory</span>)&#123;</span><br><span class="line">    string memory s = <span class="string">&quot;BinSchool.app&quot;</span>;  <span class="comment">// 声明局部变量 s</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数 <code>name</code> 中的变量 <code>s</code>，存储在 <code>memory</code> 中。当函数调用结束后，就会从内存中清除。</p>
<p>在函数中，对于“引用类型”的状态变量，<strong>可以通过关键字 <code>memory</code> 来创建它的副本。</strong></p>
<p>拿上面 <code>storage</code> 中例子，进行分析，修改了 <code>dataRef</code> 指向的数据，不会修改 <code>data</code> 指向的数据，因为memory会创建一个对应引用类型的副本。</p>
<p><strong>3. calldata</strong></p>
<p><code>calldata</code> 是外部程序在调用合约函数时，用来保存传入参数的存储位置。</p>
<p><code>calldata</code> 变量的行为类似于 <code>memory</code> 变量，它在函数调用结束后就会被销毁。两者不同之处在于，<code>calldata</code> 的数据是只读的，不能修改。与 <code>storage</code> 和 <code>memory</code> 相比，<code>calldata</code> 存储的成本最低，<code>gas</code> 消耗最少。</p>
<p><strong><code>calldata</code> 只能用于函数参数，无法在函数内部声明</strong>。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function setName(string calldata name) external;</span><br></pre></td></tr></table></figure></div>

<p><code>calldata</code> 的使用场景并不多，在函数内部，通常会转为 <code>memory</code> 再去操作。但在某些场景下，出于节省 <code>gas</code> 的目的，也会使用 <code>calldata</code> 变量。</p>
<p><strong>注意：</strong>在函数中，值类型的变量通常分配在栈上，不在上面的三种存储中。</p>
<h2 id="solidity-面向对象编程"><a href="#solidity-面向对象编程" class="headerlink" title="solidity 面向对象编程"></a>solidity 面向对象编程</h2><h3 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h3><p><strong>语法如下</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract child_contract is parent_contract &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>示例：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Person</span>&#123;</span><br><span class="line">  string public name;</span><br><span class="line">  uint public age;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getSalary</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Employee</span> is <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Snipaste_2024-07-30_11-00-34.png"
                      alt="nipaste_2024-07-30_11-00-3"
                ></p>
<p>虽然合约 <code>Employee</code> 中没有定义任何状态变量和方法，但是由于它继承了合约 <code>Person</code> ，所以在 <code>Employee</code> 中就自动拥有了状态变量 <code>name</code>、<code>age</code> 和方法 <code>getSalary</code>。</p>
<p><strong>注意</strong>：子合约只能继承父合约中可见性为 <code>public</code> 、<code>internal</code>  和 <code>external</code> 的状态变量和方法，而可见性为 <code>private</code> 的状态变量和方法，是不能被子合约继承的。</p>
<p><strong>virtual 和 override</strong></p>
<p><code>Solidity</code> 在合约继承的语法中，引入了 <code>virtual</code> 和 <code>override</code> 两个关键字，用于重写父合约中的函数。</p>
<p>父合约首先需要使用 <code>virtual</code> 关键字声明一个虚函数，然后，在子合约中使用 <code>override</code> 关键字来覆盖父合约的方法。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Person</span>&#123;</span><br><span class="line">  string public name;</span><br><span class="line">  uint public age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 virtual 声明此函数可以被子合约覆盖</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getSalary</span>(<span class="params"></span>) public pure virtual <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Employee</span> is <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 override 表示此函数覆盖了父合约的同名函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getSalary</span>(<span class="params"></span>) public pure override <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>子合约 <code>Employee</code> 的 <code>getSalary</code> 方法覆盖了父合约 <code>Person</code> 的 同名方法，调用子合约 <code>Employee</code> 的 <code>getSalary</code> 方法，输出结果是 3000，而不是父合约中的 1000。</p>
<p> <strong>注意 ：这里如果不使用 virtual 将会报错</strong></p>
<p> <strong>构造函数的继承</strong></p>
<p>如果父合约的构造函数带有参数，那么子合约在继承父合约时，就需要在自己的<strong>构造函数中显示地调用父合约的构造函数</strong>。子合约继承合约时，调用父合约的构造函数有两种方式：<strong>直接传值</strong> 和 <strong>传入输入值</strong>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Parent</span> &#123;</span><br><span class="line">  uint public data;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">uint _data</span>)&#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接传值</span></span><br><span class="line">contract <span class="title class_">Child</span> is <span class="title class_">Parent</span>(<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入输入值</span></span><br><span class="line">contract <span class="title class_">Child</span> is <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">uint _data</span>) <span class="title class_">Parent</span>(_data) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>调用父合约函数</strong></p>
<p>子合约调用父合约的函数有两种方法：<strong>使用关键字 super</strong> 和 <strong>使用合约名称</strong>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子合约 Employee</span></span><br><span class="line">contract <span class="title class_">Employee</span> is <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getSalary</span>(<span class="params"></span>) public pure override <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getPersonSalaryBySuper</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getSalary</span>(); <span class="comment">// 使用 super 调用父合约函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getPersonSalaryByName</span>(<span class="params"></span>) public pure <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Person</span>.<span class="title function_">getSalary</span>(); <span class="comment">// 使用合约名称调用父合约函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="抽象合约和接口"><a href="#抽象合约和接口" class="headerlink" title="抽象合约和接口"></a>抽象合约和接口</h3><p><strong>抽象合约</strong></p>
<p><code>Solidity</code> 允许在一个合约中只声明函数的原型，而没有具体实现，然后在继承的子合约中再去实现，这样的合约称为抽象合约。</p>
<p>抽象合约使用 <code>abstract</code> 关键字进行声明。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">abstract contract <span class="title class_">Person</span>&#123;</span><br><span class="line">  string public name;</span><br><span class="line">  uint public age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 virtual，表示函数可以被子合约覆盖</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getSalary</span>(<span class="params"></span>) public pure virtual <span class="title function_">returns</span>(uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Employee</span> is <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 override，表示覆盖了子合约的同名函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getSalary</span>(<span class="params"></span>) public pure override <span class="title function_">returns</span>(<span class="params">uint</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>abstract</code> 声明的抽象合约，通常包含至少一个未实现的函数。由于抽象合约并不完整，所以，抽象合约不能单独部署。</p>
<p><strong>接口</strong></p>
<p>定义了合约应该实现的函数名和事件，但没有实现任何函数的具体逻辑。</p>
<p>编写接口有以下限制规则：</p>
<ol>
<li>不能包含状态变量</li>
<li>不能定义结构体</li>
<li>不能包含构造函数</li>
<li>不能继承除接口外的其它合约</li>
<li>所有函数的可见性都必须是 <code>external</code>，而且不能有函数体</li>
<li>继承接口的合约必须实现接口定义的所有功能</li>
</ol>
<p>语法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">    函数声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面的代码即是一个接口的实现</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IERC20</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) external view returns (string memory);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">symbol</span>(<span class="params"></span>) external view returns (string memory);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">decimals</span>(<span class="params"></span>) external view returns (uint8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ERC20</span> is <span class="title class_">IERC20</span> &#123;</span><br><span class="line">  string _name = <span class="string">&quot;MyCoin&quot;</span>; <span class="comment">// 代币名称</span></span><br><span class="line">  string _symbol = <span class="string">&quot;MYC&quot;</span>; <span class="comment">// 代币符号</span></span><br><span class="line">  uint8 _decimals = <span class="number">18</span>; <span class="comment">// 小数精度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) external view returns (string memory) &#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">symbol</span>(<span class="params"></span>) external view returns (string memory) &#123;</span><br><span class="line">    <span class="keyword">return</span> _symbol;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">decimals</span>(<span class="params"></span>) external view returns (uint8) &#123;</span><br><span class="line">    <span class="keyword">return</span> _decimals;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>使用接口</strong></p>
<p>接口的主要作用是提供了一种约定和规范，用于与其它合约进行交互和通信。</p>
<p>在上面的例子中，编写了一个代币合约 <code>ERC20</code>，它实现了接口 <code>IERC20</code>，如果另外有一个合约，要调用已经部署在区块链上的 <code>ERC20</code> 合约，实际上非常简单，只需要知道这个合约的地址，并且知道它实现了 <code>IERC20</code> 接口，就可以在其它合约中使用它。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IERC20</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) external view returns (string memory);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">symbol</span>(<span class="params"></span>) external view returns (string memory);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">decimals</span>(<span class="params"></span>) external view returns (uint8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">UseERC20</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getToken</span>(<span class="params"></span>) external view returns (string memory,string memory,uint8) &#123;</span><br><span class="line">    <span class="comment">// 通过传入合约地址，构造调用接口</span></span><br><span class="line">    <span class="title class_">IERC20</span> token = <span class="title class_">IERC20</span>(<span class="number">0xd9145CCE52D386f254917e481eB44e9943F39138</span>); </span><br><span class="line">    <span class="keyword">return</span> (token.<span class="title function_">name</span>(),token.<span class="title function_">symbol</span>(),token.<span class="title function_">decimals</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 0xd9145CCE52D386f254917e481eB44e9943F39138 就是上面部署的实现接口的合约地址。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>语法如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract child_contract is parent_contract1, parent_contract2... &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>线性继承</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ContractA</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) public pure virtual <span class="title function_">returns</span>(<span class="params">string memory</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ContractA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ContractB</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) public pure virtual <span class="title function_">returns</span>(<span class="params">string memory</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ContractB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ChildContract</span> is <span class="title class_">ContractA</span>, <span class="title class_">ContractB</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) public pure <span class="title function_">override</span>(<span class="title class_">ContractA</span>, <span class="title class_">ContractB</span>) <span class="title function_">returns</span>(<span class="params">string memory</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>按照<strong>线性继承</strong>原则，合约的继承顺序是 <code>ContractA</code> 、<code>ContractB</code>、<code>ChildContract</code>。</p>
<p>也就是说，<code>ChildContract</code> 先继承 <code>ContractA</code> 的属性和方法，再继承 <code>ContractB</code> 的属性和方法，所以上面例子中的 super 是 <code>ContractB</code> ，调用 super.foo() 的返回结果为 “ContractB”。</p>
<p><strong>多重继承分析</strong></p>
<p>在定义合约多重继承的时候，必须正确地设置父合约的顺序，使之符合<strong>线性继承</strong>原则。如果顺序设置不正确，那么合约将无法编译。</p>
<p><strong>第一种情况</strong></p>
<p>合约 Y 继承了合约 X，合约 Z 同时继承了 X，Y。如图所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  X </span><br><span class="line">/   \</span><br><span class="line">Y   |</span><br><span class="line">\   /</span><br><span class="line">  Z</span><br></pre></td></tr></table></figure></div>

<p>这种情况下，我们按照线性继承原则，最基本的合约放在最前面，合约的继承顺序应该为：X，Y，Z。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract Z is X,Y &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果写成：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract Z is Y,X &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么编译器就会报错。</p>
<p><strong>第二种情况</strong></p>
<p>合约 Y 继承了合约 X；合约 A 也继承了合约 X，合约 B 又继承了 A；合约 Z 同时继承了 Y，B。如图所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   X </span><br><span class="line"> /   \</span><br><span class="line">Y     A</span><br><span class="line">|     |</span><br><span class="line">|     B</span><br><span class="line"> \   / </span><br><span class="line">   Z</span><br></pre></td></tr></table></figure></div>

<p>这种情况下，按照线性继承原则，最终理清的合约继承顺序为：X，Y，A，B，Z。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract Z is Y,B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>




        </div>

        
            <div class="post-copyright-info my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> blockchain solidity基础</li>
        <li><strong>Author:</strong> henry</li>
        <li><strong>Created at
                :</strong> 2024-07-30 11:38:55</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-07-30 11:40:32
            </li>
        
        <li>
            <strong>Link:</strong> https://henrymartin262.github.io/2024/07/30/solidity_study/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/blockchain%EF%BC%8Csolidity/">#blockchain，solidity</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/07/31/1.0_Introduction/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">南大《软件分析》1.0 Introduction</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2024/07/29/llvm_ebpf/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">LLVM ebpf 汇编学习</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container pjax">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail']
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">blockchain solidity基础</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-text">Reference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solidity-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">solidity 基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-text">整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="nav-text">布尔型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%9E%8B"><span class="nav-text">地址型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%9E%8B"><span class="nav-text">枚举型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solidity-%E5%8F%98%E9%87%8F"><span class="nav-text">solidity 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-text">常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solidity-%E5%87%BD%E6%95%B0"><span class="nav-text">solidity 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8F%AF%E5%8F%98%E6%80%A7-visibility"><span class="nav-text">状态可变性 visibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E5%87%BD%E6%95%B0-receive"><span class="nav-text">接受函数 receive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0-fallback"><span class="nav-text">回退函数 fallback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#receive-%E5%92%8C-fallback-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">receive 和 fallback 工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solidity-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-text">solidity 流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%E8%AF%AD%E5%8F%A5"><span class="nav-text">断言语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solidity-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">solidity 复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字节和字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-text">映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">值类型和引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="nav-text">数据位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solidity-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-text">solidity 面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E7%BA%A6%E7%BB%A7%E6%89%BF"><span class="nav-text">合约继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-text">抽象合约和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">多重继承</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">henry</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.6</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/libs/anime.min.js"></script>

        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


    <div id="aplayer"></div>

<script src="/js/libs/APlayer.min.js"></script>


<script src="/js/plugins/aplayer.js"></script>


</body>
</html>
